{"version":3,"sources":["table-neat-width.js","_usable-view.js"],"names":["window","NACSS","NS","_createHeaderClone","tab","cm","thead","tHead","trs","tBodies","rows","length","containsOnlyTh","tr","tds","getElementsByTagName","ths","trsH","push","createTHead","appendChild","_createPseudoHeader","hc","document","createElement","enableClass","styleHeaderContainer","parentNode","ht","styleHeaderTable","cloneNode","_createBarClone","bar","styleScrollBar","spacer","onResize","r","head","style","overflowX","scrollWidth","clientWidth","tw","width","getBoundingClientRect","maxWidth","display","top","offset","hw","firstChild","oTrs","cTrs","i","copyWidth","o","c","tag","os","cs","_updateHeaderSize","disabled","pointerEvents","h","parseInt","parent","d","setAttribute","getComputedStyle","getPropertyValue","overflowY","minHeight","cw","offsetWidth","removeChild","getScrollBarWidth","documentElement","height","_updateScrollBarSize","onWindowScroll","onTableScroll","tBottom","bottom","rh","hTop","hBottom","wY0","wY1","innerHeight","inView","capableWindowHeightRate","tLeft","left","tScrollLeft","scrollLeft","hCy","offsetHeight","visible","tabLeft","tabScrollLeft","_updateHeaderVisibility","_updateBarVisibility","sL","Math","max","min","styleScrollRight","styleScrollLeft","tableNeatWidth","tabs","opts","Object","assign","styleFixedHeader","ts","forced","el","tar","op","throttle","addEventListener","ro","ResizeObserver","es","e","idx","indexOf","target","contentRect","t","observe","passive","sel","cls","startsWith","substr","replace","charAt","toLowerCase","elm","querySelector"],"mappings":"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","file":"table-neat-width.min.js","sourcesContent":["/**\n *\n * Table Style - Neat Width (JS)\n *\n * @author Takuto Yanagida\n * @version 2021-01-25\n *\n */\n\n\nwindow.NACSS = window['NACSS'] || {};\n\n\n(function (NS) {\n\n\t/**\n\t *\n\t * Neat Width\n\t *\n\t * @author Takuto Yanagida\n\t * @version 2021-01-25\n\t *\n\t */\n\t\n\t\n\tfunction initialize(tabs, opts = {}) {\n\t\tif (tabs.length === 0) return;\n\t\n\t\tconst lt = tabs[tabs.length - 1];\n\t\tconst cm = Object.assign({\n\t\t\tfullWidthRate   : 0.95,\n\t\t\tcellMinWidth    : 80,\n\t\t\tcellMinAspect   : 2 / 3,  // width / height\n\t\t\tcellMinLength   : 8,\n\t\t\tmaxRowSize      : 200,\n\t\t\tmaxBorderWidth  : 2,\n\t\t\tbefore          : null,  // function (table) { ...; return delay; }\n\t\t\tafter           : null,  // function (table) { ... }\n\t\t\tstyleNeat       : ':ncTableNeat',\n\t\t\tstyleFull       : ':ncTableFull',\n\t\t\tstyleScrollRight: ':ncScrollRight',\n\t\t\tstyleScrollLeft : ':ncScrollLeft',\n\t\t}, opts, getCommonMetrics(lt));\n\t\n\t\tcm.padH += cm.maxBorderWidth * 2;\n\t\tcm.padV += cm.maxBorderWidth * 2;\n\t\tcm.dcTd = makeDummyCell(lt, 'td');\n\t\tcm.dcTh = makeDummyCell(lt, 'th');\n\t\n\t\tconst tarTabs = [], noTarTabs = [];\n\t\tfor (const t of tabs) {\n\t\t\tif (isTarget(t, cm)) tarTabs.push(t);\n\t\t\telse noTarTabs.push(t);\n\t\t}\n\t\tcm.gcCount = tarTabs.length;\n\t\n\t\tfor (const t of tarTabs) {\n\t\t\tconst delay = (cm.before) ? (cm.before(t) ?? 0) : false;\n\t\t\tst(() => {\n\t\t\t\tapply(t, cm);\n\t\t\t\tenableClass(true, t, cm.styleNeat);\n\t\t\t\tif (cm.after) cm.after(t);\n\t\t\t\tif (--cm.gcCount === 0) removeDummyCell(lt, cm);\n\t\t\t}, delay);\n\t\t}\n\t\tif (cm.fullWidthRate) {\n\t\t\tfor (const t of noTarTabs) {\n\t\t\t\tconst pw = t.parentElement.clientWidth;\n\t\t\t\tif (pw * cm.fullWidthRate < t.clientWidth) enableClass(true, t, cm.styleFull);\n\t\t\t}\n\t\t}\n\t\tfunction st(fn, d) { (d === false) ? fn() : setTimeout(fn, d); }\n\t\tinitScroll(tarTabs, cm);\n\t}\n\t\n\tfunction getCommonMetrics(tab) {\n\t\tconst td = tab.getElementsByTagName('td')[0];\n\t\tconst s = getComputedStyle(td);\n\t\tconst padH  = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);\n\t\tconst padV  = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);\n\t\tconst [charW, lineH] = getTextSize(td);\n\t\treturn { padH, padV, charW, lineH };\n\t}\n\t\n\tfunction getTextSize(elm) {\n\t\tconst d = document.createElement(elm.nodeName);\n\t\td.setAttribute('style', `position:fixed;margin:0;padding:0;font-family:${elm.style.fontFamily || 'inherit'};font-size:${elm.style.fontSize || 'inherit'};`);\n\t\td.innerHTML = '\\u3000';  // Full width space\n\t\telm.parentNode.appendChild(d);\n\t\tconst w = d.clientWidth;\n\t\tconst h = d.clientHeight;\n\t\td.parentNode.removeChild(d);\n\t\treturn [w, h];\n\t}\n\t\n\tfunction makeDummyCell(t, tagName) {\n\t\tconst d = document.createElement(tagName);\n\t\td.setAttribute('style', `position:fixed;display:inline-block;visibility:hidden;white-space:nowrap;`);\n\t\treturn t.appendChild(d);\n\t}\n\t\n\tfunction removeDummyCell(lt, cMat) {\n\t\tlt.removeChild(cMat.dcTd);\n\t\tlt.removeChild(cMat.dcTh);\n\t}\n\t\n\tfunction isTarget(tab, cMet) {\n\t\tif (tab.rows.length === 0) return false;\n\t\tif (cMet.maxRowSize < tab.rows.length) return false;\n\t\n\t\tconst { cellMinWidth, cellMinAspect } = cMet;\n\t\tfor (const tr of tab.rows) {\n\t\t\tif (!tr.hasChildNodes()) continue;\n\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\tconst tn = n.tagName;\n\t\t\t\tif (tn !== 'TD' && tn !== 'TH') continue;\n\t\t\t\tif (1 < parseInt(n.getAttribute('colSpan'), 10)) continue;\n\t\t\t\tif (1 < parseInt(n.getAttribute('rowSpan'), 10)) continue;\n\t\t\t\tconst cw = n.clientWidth;\n\t\t\t\tconst ch = n.clientHeight;\n\t\t\t\tif (cw < cellMinWidth || cw / ch < cellMinAspect) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction initScroll(tabs, cMet) {\n\t\tconst rob = new ResizeObserver(oes => {\n\t\t\tfor (const oe of oes) onScroll(oe.target, cMet);\n\t\t});\n\t\tfor (const t of tabs) {\n\t\t\trob.observe(t);\n\t\t\tt.addEventListener('scroll', throttle(() => { onScroll(t, cMet); }));\n\t\t}\n\t}\n\t\n\tfunction onScroll(tab, cMet) {\n\t\tif (tab.scrollWidth - tab.clientWidth > 2) {  // for avoiding needless scrolling\n\t\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\n\t\t\tenableClass(r < 0.95, tab, cMet.styleScrollRight);\n\t\t\tenableClass(0.05 < r, tab, cMet.styleScrollLeft);\n\t\t} else {\n\t\t\tenableClass(false, tab, cMet.styleScrollRight);\n\t\t\tenableClass(false, tab, cMet.styleScrollLeft);\n\t\t}\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction apply(tab, cMet) {\n\t\ttab.removeAttribute('width');\n\t\tif (tab.style.width) tab.style.width = null;\n\t\tif (tab.style.height) tab.style.height = null;\n\t\n\t\tconst grid  = makeCellGrid(tab);\n\t\tconst met   = Object.assign(getMetrics(tab, grid), cMet);\n\t\tconst newWs = calcNewWidths(grid, met);\n\t\tsetCellWidth(grid, newWs);\n\t\n\t\tconst cs = tab.getElementsByTagName('caption');\n\t\tif (cs.length) cs[0].innerHTML = `<span>${cs[0].innerHTML}</span>`;\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction makeCellGrid(t) {\n\t\tconst css = collectCells(t);\n\t\tlet maxWidth = 0;\n\t\tfor (const cs of css) maxWidth = Math.max(maxWidth, cs.length);\n\t\tconst g = [];\n\t\tfor (const cs of css) g.push(new Array(maxWidth));\n\t\n\t\tfor (let y = 0; y < g.length; y += 1) {\n\t\t\tconst gr = g[y];\n\t\t\tconst tds = css[y];\n\t\t\tlet i = 0;\n\t\n\t\t\tfor (let x = 0; x < maxWidth; x += 1) {\n\t\t\t\tif (typeof gr[x] === 'number' || gr[x] === null) continue;\n\t\n\t\t\t\tconst td = tds[i]\n\t\t\t\tconst col = parseInt(td.getAttribute('colSpan') ?? 1, 10);\n\t\t\t\tconst row = parseInt(td.getAttribute('rowSpan') ?? 1, 10);\n\t\t\t\tgr[x] = td;\n\t\n\t\t\t\tif (1 < col) {\n\t\t\t\t\tfor (let p = 1; p < col; p += 1) gr[x + p] = p;\n\t\t\t\t}\n\t\t\t\tif (1 < row) {\n\t\t\t\t\tfor (let q = 1; q < row; q += 1) {\n\t\t\t\t\t\tconst nr = g[y + q];\n\t\t\t\t\t\tfor (let p = 0; p < col; p += 1) nr[x + p] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti += 1;\n\t\t\t\tif (tds.length <= i) break;\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tfunction collectCells(t, css = []) {\n\t\tfor (const tr of t.rows) {\n\t\t\tconst cs = [];\n\t\t\tif (tr.hasChildNodes()) {\n\t\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\t\tconst tn = n.tagName;\n\t\t\t\t\tif (tn === 'TD' || tn === 'TH') cs.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcss.push(cs);\n\t\t}\n\t\treturn css;\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction getMetrics(tab, grid) {\n\t\tconst origTabW = tab.clientWidth;\n\t\tconst origCellWs = [];\n\t\tfor (let x = 0; x < grid[0].length; x += 1) {\n\t\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\t\tconst g = grid[y][x];\n\t\t\t\tif (g instanceof HTMLTableCellElement && !g.getAttribute('colSpan')) {\n\t\t\t\t\torigCellWs.push(g.clientWidth);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { origTabW, origCellWs };\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction calcNewWidths(grid, met) {\n\t\tfor (const gr of grid) {\n\t\t\tfor (const gc of gr) {\n\t\t\t\tif (typeof gc !== 'number' && gc !== null) gc.style.whiteSpace = 'nowrap';\n\t\t\t}\n\t\t}\n\t\tconst gw = grid[0].length;\n\t\tconst newWs = new Array(gw).fill(0);\n\t\tconst fixWs = new Array(gw).fill(0);\n\t\n\t\tfor (const gr of grid) {\n\t\t\tfor (let x = 0; x < gw; x += 1) {\n\t\t\t\tconst td = gr[x];\n\t\t\t\tif (td === undefined || td === null || typeof td === 'number') continue;\n\t\t\t\tif (x < gw - 1 && typeof gr[x + 1] === 'number') continue;\n\t\t\t\tif (1 < parseInt(td.getAttribute('colSpan'), 10)) continue;\n\t\t\t\tif (1 < parseInt(td.getAttribute('rowSpan'), 10)) continue;\n\t\n\t\t\t\tconst minW = calcMinWidth(td, met);\n\t\t\t\tnewWs[x] = Math.max(newWs[x], minW);\n\t\t\t\tif (!minW) fixWs[x] = Math.max(fixWs[x], td.clientWidth);\n\t\t\t}\n\t\t}\n\t\twidenTabWidth(newWs, fixWs, met);\n\t\treturn newWs;\n\t}\n\t\n\tfunction calcMinWidth(td, met) {\n\t\tconst { padH, padV, charW, lineH, dcTd, dcTh, cellMinWidth, cellMinAspect, cellMinLength } = met;\n\t\tif (calcMaxLineLength(td) < cellMinLength) return 0;\n\t\n\t\ttd.innerHTML = td.innerHTML.trim();\n\t\tconst dc = td.tagName === 'TD' ? dcTd : dcTh;\n\t\tdc.innerHTML = td.innerHTML;\n\t\tconst aw = dc.clientWidth - padH;\n\t\tconst ls = Math.round((dc.clientHeight - padV) / lineH);\n\t\tlet minW = 0;\n\t\tfor (let i = 2;; i += 1) {\n\t\t\tconst tempW = 0 | (aw / i + charW * i + padH);\n\t\t\tconst tempH = ls * (i * lineH) + padV;\n\t\t\tif (tempW < cellMinWidth || tempW / tempH < cellMinAspect || (minW && minW < tempW)) break;\n\t\t\tminW = tempW;\n\t\t}\n\t\treturn (minW + charW < dc.clientWidth) ? minW : 0;\n\t}\n\t\n\tfunction calcMaxLineLength(td) {\n\t\tconst ih = td.innerHTML.trim();\n\t\tconst ls = ih.split(/<\\s*br\\s*\\/?>/ui);\n\t\tconst ts = ls.map(e => e.replace(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/g, '').length);\n\t\treturn Math.max(...ts);\n\t}\n\t\n\tfunction widenTabWidth(newWs, fixWs, met) {\n\t\tconst { origTabW, origCellWs } = met;\n\t\tlet wNew = 0, wFix = 0;\n\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\tif (newWs[i]) {\n\t\t\t\twNew += newWs[i];\n\t\t\t} else {\n\t\t\t\twFix += fixWs[i];\n\t\t\t}\n\t\t}\n\t\tif (origTabW < wNew + wFix) return;\n\t\tlet rem = origTabW - wFix;\n\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\tif (!newWs[i]) continue;\n\t\t\tconst nw = newWs[i];\n\t\t\tconst w = Math.min(nw / wNew * rem, origCellWs[i]);\n\t\t\trem  -= (w - nw);\n\t\t\twNew -= (w - nw);\n\t\t\tnewWs[i] = 0 | w;\n\t\t}\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction setCellWidth(grid, ws) {\n\t\tfor (const gr of grid) {\n\t\t\tfor (let x = 0; x < gr.length; x += 1) {\n\t\t\t\tconst gc = gr[x], w = ws[x];\n\t\t\t\tif (!w || !(gc instanceof HTMLTableCellElement)) continue;\n\t\t\t\tgc.style.whiteSpace = null;\n\t\t\t\tgc.style.minWidth   = w + 'px';\n\t\t\t\tgc.style.width      = null;\n\t\t\t}\n\t\t}\n\t}\n\tNS.tableNeatWidth = initialize;\n\n\t/**\r\n\t *\r\n\t * Usable View\r\n\t *\r\n\t * @author Takuto Yanagida\r\n\t * @version 2021-01-25\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\tfunction initialize(tabs, opts = {}) {\r\n\t\tif (tabs.length === 0) return;\r\n\t\tconst cm = Object.assign({\r\n\t\t\tcapableWindowHeightRate: 0.9,\r\n\t\t\tstyleHeaderContainer   : ':ncTableFixedHeaderContainer',\r\n\t\t\tstyleHeaderTable       : ':ncTableFixedHeaderTable',\r\n\t\t\tstyleScrollBar         : ':ncTableFixedScrollBar',\r\n\t\r\n\t\t\tstyleFixedHeader       : ':ncFixedHeader',\r\n\t\t\tstyleScrollRight       : ':ncScrollRight',\r\n\t\t\tstyleScrollLeft        : ':ncScrollLeft',\r\n\t\t\toffset                 : 0,\r\n\t\t}, opts);\r\n\t\r\n\t\tconst cs = [], ts = [...tabs];\r\n\t\tfor (const tab of ts) {\r\n\t\t\tconst head = _createHeaderClone(tab, cm);\r\n\t\t\tconst bar  = _createBarClone(tab, cm);\r\n\t\t\tcs.push({ tab, head, bar });\r\n\t\r\n\t\t\tlet forced = false;\r\n\t\t\tconst el = (tar, op) => throttle(() => {\r\n\t\t\t\tif (forced) {\r\n\t\t\t\t\tforced = false;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tforced = true;\r\n\t\t\t\t\top.scrollLeft = tar.scrollLeft;\r\n\t\t\t\t\tif (head) onTableScroll(tab, head, cm);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\ttab.addEventListener('scroll', el(tab, bar));\r\n\t\t\tbar.addEventListener('scroll', el(bar, tab));\r\n\t\t}\r\n\t\tconst ro = new ResizeObserver((es) => {\r\n\t\t\tfor (const e of es) {\r\n\t\t\t\tconst idx = ts.indexOf(e.target);\r\n\t\t\t\tconst c = cs[idx];\r\n\t\t\t\tonResize(e.contentRect, c.tab, c.head, c.bar, cm);\r\n\t\t\t}\r\n\t\t});\r\n\t\tfor (const t of ts) ro.observe(t);\r\n\t\r\n\t\twindow.addEventListener('scroll', throttle(() => {\r\n\t\t\tfor (const c of cs) onWindowScroll(c.tab, c.head, c.bar, cm);\r\n\t\t}), { passive: true });\r\n\t\r\n\t\tconst sel = getSelector(cm.styleFixedHeader);\r\n\t\tif (sel) {\r\n\t\t\tconst elm = document.querySelector(sel);\r\n\t\t\tif (elm) {\r\n\t\t\t\tconst rob = new ResizeObserver(es => {\r\n\t\t\t\t\tcm.offset = es[0].contentRect.bottom;\r\n\t\t\t\t\tfor (const c of cs) onResize(null, c.tab, c.head, c.bar, cm);\r\n\t\t\t\t});\r\n\t\t\t\trob.observe(elm);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction _createHeaderClone(tab, cm) {\r\n\t\tlet thead = tab.tHead;\r\n\t\tif (!thead) {\r\n\t\t\tthead = _createPseudoHeader(tab);\r\n\t\t\tif (!thead) return null;\r\n\t\t\ttab.tHead = thead;\r\n\t\t}\r\n\t\tconst hc = document.createElement('div');\r\n\t\tenableClass(true, hc, cm.styleHeaderContainer);\r\n\t\ttab.parentNode.appendChild(hc);\r\n\t\r\n\t\tconst ht = document.createElement('div');\r\n\t\tenableClass(true, ht, cm.styleHeaderTable);\r\n\t\thc.appendChild(ht);\r\n\t\r\n\t\tht.appendChild(thead.cloneNode(true));\r\n\t\treturn hc;\r\n\t}\r\n\t\r\n\tfunction _createPseudoHeader(tab) {\r\n\t\tconst trs = tab.tBodies[0].rows;\r\n\t\tif (trs.length === 0) return null;\r\n\t\r\n\t\tfunction containsOnlyTh(tr) {\r\n\t\t\tconst tds = tr.getElementsByTagName('td');\r\n\t\t\tconst ths = tr.getElementsByTagName('th');\r\n\t\t\tif (tds.length === 0 && ths.length > 0) return true;\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tconst trsH = [];\r\n\t\tfor (const tr of trs) {\r\n\t\t\tif (!containsOnlyTh(tr)) break;\r\n\t\t\ttrsH.push(tr);\r\n\t\t}\r\n\t\tif (trsH.length === 0) return null;\r\n\t\r\n\t\tconst thead = tab.createTHead();\r\n\t\tfor (const tr of trsH) thead.appendChild(tr);\r\n\t\treturn thead;\r\n\t}\r\n\t\r\n\tfunction _createBarClone(tab, cm) {\r\n\t\tconst bar = document.createElement('div');\r\n\t\tenableClass(true, bar, cm.styleScrollBar);\r\n\t\tconst spacer = document.createElement('div');\r\n\t\tbar.appendChild(spacer);\r\n\t\ttab.parentNode.appendChild(bar);\r\n\t\treturn bar;\r\n\t}\r\n\t\r\n\t\r\n\t// ---------------------------------------------------------------------\r\n\t\r\n\t\r\n\tfunction onResize(r, tab, head, bar, cm) {\r\n\t\ttab.style.overflowX = (tab.scrollWidth < tab.clientWidth + 2) ? 'hidden' : null;\r\n\t\r\n\t\tif (head) _updateHeaderSize(r, tab, head, cm);\r\n\t\tif (bar) _updateScrollBarSize(tab, bar);\r\n\t\tif (head || bar) onWindowScroll(tab, head, bar, cm);\r\n\t\tif (head) onTableScroll(tab, head, cm);\r\n\t}\r\n\t\r\n\tfunction _updateHeaderSize(r, tab, head, cm) {\r\n\t\tconst tw = r ? r.width : tab.getBoundingClientRect().width;\r\n\t\thead.style.maxWidth = tw + 'px';\r\n\t\thead.style.display  = 'none';\r\n\t\thead.style.top      = cm.offset + 'px';\r\n\t\r\n\t\tconst thead = tab.tHead;\r\n\t\tconst hw = thead.getBoundingClientRect().width;\r\n\t\tconst ht = head.firstChild;\r\n\t\tht.style.width = hw + 'px';\r\n\t\r\n\t\tconst oTrs = thead.rows;\r\n\t\tconst cTrs = ht.firstChild.rows;\r\n\t\tfor (let i = 0; i < oTrs.length; i += 1) {\r\n\t\t\tcopyWidth(oTrs[i], cTrs[i], 'td');\r\n\t\t\tcopyWidth(oTrs[i], cTrs[i], 'th');\r\n\t\t}\r\n\t\tfunction copyWidth(o, c, tag) {\r\n\t\t\tconst os = o.getElementsByTagName(tag);\r\n\t\t\tconst cs = c.getElementsByTagName(tag);\r\n\t\t\tfor (let i = 0; i < os.length; i += 1) {\r\n\t\t\t\tcs[i].style.width = os[i].getBoundingClientRect().width + 'px';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction _updateScrollBarSize(tab, bar) {\r\n\t\tconst disabled = (tab.scrollWidth < tab.clientWidth + 2);\r\n\t\tbar.style.overflowX = disabled ? 'hidden' : null;\r\n\t\tbar.style.pointerEvents = disabled ? 'none' : null;\r\n\t\r\n\t\tbar.style.maxWidth = `${tab.clientWidth}px`;\r\n\t\tbar.style.display = 'none';\r\n\t\tconst h = parseInt(getScrollBarWidth(document.documentElement));\r\n\t\tif (0 < h) bar.style.height = (h + 2) + 'px';\r\n\t\tbar.firstChild.style.width = `${tab.scrollWidth}px`;\r\n\t}\r\n\t\r\n\t\r\n\t// ---------------------------------------------------------------------\r\n\t\r\n\t\r\n\tfunction onWindowScroll(tab, head, bar, cm) {\r\n\t\tconst r = tab.getBoundingClientRect();\r\n\t\tconst tBottom = r.bottom;\r\n\t\tconst rh = tab.tHead.getBoundingClientRect();\r\n\t\tconst hTop = rh.top, hBottom = rh.bottom;\r\n\t\tconst wY0 = cm.offset, wY1 = window.innerHeight;\r\n\t\r\n\t\tconst inView = tBottom - hTop < cm.capableWindowHeightRate * (wY1 - wY0);\r\n\t\tconst tLeft = r.left, tScrollLeft = tab.scrollLeft;\r\n\t\tif (head) {\r\n\t\t\tconst hCy = tab.tHead.offsetHeight;\r\n\t\t\tconst f = (!inView && hTop < wY0 && wY0 < tBottom - hCy);\r\n\t\t\t_updateHeaderVisibility(head, f, tLeft, tScrollLeft);\r\n\t\t}\r\n\t\tif (bar) {\r\n\t\t\tconst f = (!inView && hBottom < wY1 && wY1 < tBottom);\r\n\t\t\t_updateBarVisibility(bar, f, tLeft, tScrollLeft);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction _updateHeaderVisibility(head, visible, tabLeft, tabScrollLeft) {\r\n\t\thead.style.display = visible ? 'block' : 'none';\r\n\t\thead.style.left    = tabLeft + 'px';\r\n\t\thead.scrollLeft    = tabScrollLeft;\r\n\t}\r\n\t\r\n\tfunction _updateBarVisibility(bar, visible, tabLeft, tabScrollLeft) {\r\n\t\tbar.style.display = visible ? 'block' : 'none';\r\n\t\tbar.style.left    = tabLeft + 'px';\r\n\t\tbar.scrollLeft    = tabScrollLeft;\r\n\t}\r\n\t\r\n\t\r\n\t// ---------------------------------------------------------------------\r\n\t\r\n\t\r\n\tfunction onTableScroll(tab, head, cm) {\r\n\t\tconst sL = Math.max(0, Math.min(tab.scrollLeft, tab.scrollWidth - tab.offsetWidth));  // for iOS\r\n\t\thead.scrollLeft = sL;\r\n\t\r\n\t\tif (tab.scrollWidth - tab.clientWidth > 2) {  // for avoiding needless scrolling\r\n\t\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\r\n\t\t\tenableClass(r < 0.95, head, cm.styleScrollRight);\r\n\t\t\tenableClass(0.05 < r, head, cm.styleScrollLeft);\r\n\t\t} else {\r\n\t\t\tenableClass(false, head, cm.styleScrollRight);\r\n\t\t\tenableClass(false, head, cm.styleScrollLeft);\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\t// Utilities ---------------------------------------------------------------\r\n\t\r\n\t\r\n\tfunction getSelector(cls) {\r\n\t\tif (cls.startsWith(':')) {\r\n\t\t\treturn `*[data-${cls.substr(1).replace(/([A-Z])/g, c => '-' + c.charAt(0).toLowerCase())}]`;\r\n\t\t} else {\r\n\t\t\treturn `*${cls}`;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction getScrollBarWidth(parent) {\r\n\t\tconst d = document.createElement('div');\r\n\t\td.setAttribute('style', 'position:absolute;bottom:100%;width:calc(100vw - 100%);height:1px;');\r\n\t\tparent.appendChild(d);\r\n\t\tlet width = 0 | window.getComputedStyle(d).getPropertyValue('width');\r\n\t\r\n\t\tif (width === 0) {  // Window does not have any scroll bar\r\n\t\t\td.style.overflowY = 'scroll';\r\n\t\t\td.style.width = '';\r\n\t\t\tconst c = document.createElement('div');\r\n\t\t\tc.style.minHeight = '100px';\r\n\t\t\td.appendChild(c);\r\n\t\t\tconst cw = 0 | window.getComputedStyle(c).getPropertyValue('width');\r\n\t\t\twidth = d.offsetWidth - cw;\r\n\t\t}\r\n\t\tparent.removeChild(d);\r\n\t\treturn width;\r\n\t}\n\n})(window.NACSS);\n","/**\r\n *\r\n * Usable View\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2021-01-25\r\n *\r\n */\r\n\r\n\r\nfunction initialize(tabs, opts = {}) {\r\n\tif (tabs.length === 0) return;\r\n\tconst cm = Object.assign({\r\n\t\tcapableWindowHeightRate: 0.9,\r\n\t\tstyleHeaderContainer   : ':ncTableFixedHeaderContainer',\r\n\t\tstyleHeaderTable       : ':ncTableFixedHeaderTable',\r\n\t\tstyleScrollBar         : ':ncTableFixedScrollBar',\r\n\r\n\t\tstyleFixedHeader       : ':ncFixedHeader',\r\n\t\tstyleScrollRight       : ':ncScrollRight',\r\n\t\tstyleScrollLeft        : ':ncScrollLeft',\r\n\t\toffset                 : 0,\r\n\t}, opts);\r\n\r\n\tconst cs = [], ts = [...tabs];\r\n\tfor (const tab of ts) {\r\n\t\tconst head = _createHeaderClone(tab, cm);\r\n\t\tconst bar  = _createBarClone(tab, cm);\r\n\t\tcs.push({ tab, head, bar });\r\n\r\n\t\tlet forced = false;\r\n\t\tconst el = (tar, op) => throttle(() => {\r\n\t\t\tif (forced) {\r\n\t\t\t\tforced = false;\r\n\t\t\t} else {\r\n\t\t\t\tforced = true;\r\n\t\t\t\top.scrollLeft = tar.scrollLeft;\r\n\t\t\t\tif (head) onTableScroll(tab, head, cm);\r\n\t\t\t}\r\n\t\t});\r\n\t\ttab.addEventListener('scroll', el(tab, bar));\r\n\t\tbar.addEventListener('scroll', el(bar, tab));\r\n\t}\r\n\tconst ro = new ResizeObserver((es) => {\r\n\t\tfor (const e of es) {\r\n\t\t\tconst idx = ts.indexOf(e.target);\r\n\t\t\tconst c = cs[idx];\r\n\t\t\tonResize(e.contentRect, c.tab, c.head, c.bar, cm);\r\n\t\t}\r\n\t});\r\n\tfor (const t of ts) ro.observe(t);\r\n\r\n\twindow.addEventListener('scroll', throttle(() => {\r\n\t\tfor (const c of cs) onWindowScroll(c.tab, c.head, c.bar, cm);\r\n\t}), { passive: true });\r\n\r\n\tconst sel = getSelector(cm.styleFixedHeader);\r\n\tif (sel) {\r\n\t\tconst elm = document.querySelector(sel);\r\n\t\tif (elm) {\r\n\t\t\tconst rob = new ResizeObserver(es => {\r\n\t\t\t\tcm.offset = es[0].contentRect.bottom;\r\n\t\t\t\tfor (const c of cs) onResize(null, c.tab, c.head, c.bar, cm);\r\n\t\t\t});\r\n\t\t\trob.observe(elm);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction _createHeaderClone(tab, cm) {\r\n\tlet thead = tab.tHead;\r\n\tif (!thead) {\r\n\t\tthead = _createPseudoHeader(tab);\r\n\t\tif (!thead) return null;\r\n\t\ttab.tHead = thead;\r\n\t}\r\n\tconst hc = document.createElement('div');\r\n\tenableClass(true, hc, cm.styleHeaderContainer);\r\n\ttab.parentNode.appendChild(hc);\r\n\r\n\tconst ht = document.createElement('div');\r\n\tenableClass(true, ht, cm.styleHeaderTable);\r\n\thc.appendChild(ht);\r\n\r\n\tht.appendChild(thead.cloneNode(true));\r\n\treturn hc;\r\n}\r\n\r\nfunction _createPseudoHeader(tab) {\r\n\tconst trs = tab.tBodies[0].rows;\r\n\tif (trs.length === 0) return null;\r\n\r\n\tfunction containsOnlyTh(tr) {\r\n\t\tconst tds = tr.getElementsByTagName('td');\r\n\t\tconst ths = tr.getElementsByTagName('th');\r\n\t\tif (tds.length === 0 && ths.length > 0) return true;\r\n\t\treturn false;\r\n\t}\r\n\tconst trsH = [];\r\n\tfor (const tr of trs) {\r\n\t\tif (!containsOnlyTh(tr)) break;\r\n\t\ttrsH.push(tr);\r\n\t}\r\n\tif (trsH.length === 0) return null;\r\n\r\n\tconst thead = tab.createTHead();\r\n\tfor (const tr of trsH) thead.appendChild(tr);\r\n\treturn thead;\r\n}\r\n\r\nfunction _createBarClone(tab, cm) {\r\n\tconst bar = document.createElement('div');\r\n\tenableClass(true, bar, cm.styleScrollBar);\r\n\tconst spacer = document.createElement('div');\r\n\tbar.appendChild(spacer);\r\n\ttab.parentNode.appendChild(bar);\r\n\treturn bar;\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------\r\n\r\n\r\nfunction onResize(r, tab, head, bar, cm) {\r\n\ttab.style.overflowX = (tab.scrollWidth < tab.clientWidth + 2) ? 'hidden' : null;\r\n\r\n\tif (head) _updateHeaderSize(r, tab, head, cm);\r\n\tif (bar) _updateScrollBarSize(tab, bar);\r\n\tif (head || bar) onWindowScroll(tab, head, bar, cm);\r\n\tif (head) onTableScroll(tab, head, cm);\r\n}\r\n\r\nfunction _updateHeaderSize(r, tab, head, cm) {\r\n\tconst tw = r ? r.width : tab.getBoundingClientRect().width;\r\n\thead.style.maxWidth = tw + 'px';\r\n\thead.style.display  = 'none';\r\n\thead.style.top      = cm.offset + 'px';\r\n\r\n\tconst thead = tab.tHead;\r\n\tconst hw = thead.getBoundingClientRect().width;\r\n\tconst ht = head.firstChild;\r\n\tht.style.width = hw + 'px';\r\n\r\n\tconst oTrs = thead.rows;\r\n\tconst cTrs = ht.firstChild.rows;\r\n\tfor (let i = 0; i < oTrs.length; i += 1) {\r\n\t\tcopyWidth(oTrs[i], cTrs[i], 'td');\r\n\t\tcopyWidth(oTrs[i], cTrs[i], 'th');\r\n\t}\r\n\tfunction copyWidth(o, c, tag) {\r\n\t\tconst os = o.getElementsByTagName(tag);\r\n\t\tconst cs = c.getElementsByTagName(tag);\r\n\t\tfor (let i = 0; i < os.length; i += 1) {\r\n\t\t\tcs[i].style.width = os[i].getBoundingClientRect().width + 'px';\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction _updateScrollBarSize(tab, bar) {\r\n\tconst disabled = (tab.scrollWidth < tab.clientWidth + 2);\r\n\tbar.style.overflowX = disabled ? 'hidden' : null;\r\n\tbar.style.pointerEvents = disabled ? 'none' : null;\r\n\r\n\tbar.style.maxWidth = `${tab.clientWidth}px`;\r\n\tbar.style.display = 'none';\r\n\tconst h = parseInt(getScrollBarWidth(document.documentElement));\r\n\tif (0 < h) bar.style.height = (h + 2) + 'px';\r\n\tbar.firstChild.style.width = `${tab.scrollWidth}px`;\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------\r\n\r\n\r\nfunction onWindowScroll(tab, head, bar, cm) {\r\n\tconst r = tab.getBoundingClientRect();\r\n\tconst tBottom = r.bottom;\r\n\tconst rh = tab.tHead.getBoundingClientRect();\r\n\tconst hTop = rh.top, hBottom = rh.bottom;\r\n\tconst wY0 = cm.offset, wY1 = window.innerHeight;\r\n\r\n\tconst inView = tBottom - hTop < cm.capableWindowHeightRate * (wY1 - wY0);\r\n\tconst tLeft = r.left, tScrollLeft = tab.scrollLeft;\r\n\tif (head) {\r\n\t\tconst hCy = tab.tHead.offsetHeight;\r\n\t\tconst f = (!inView && hTop < wY0 && wY0 < tBottom - hCy);\r\n\t\t_updateHeaderVisibility(head, f, tLeft, tScrollLeft);\r\n\t}\r\n\tif (bar) {\r\n\t\tconst f = (!inView && hBottom < wY1 && wY1 < tBottom);\r\n\t\t_updateBarVisibility(bar, f, tLeft, tScrollLeft);\r\n\t}\r\n}\r\n\r\nfunction _updateHeaderVisibility(head, visible, tabLeft, tabScrollLeft) {\r\n\thead.style.display = visible ? 'block' : 'none';\r\n\thead.style.left    = tabLeft + 'px';\r\n\thead.scrollLeft    = tabScrollLeft;\r\n}\r\n\r\nfunction _updateBarVisibility(bar, visible, tabLeft, tabScrollLeft) {\r\n\tbar.style.display = visible ? 'block' : 'none';\r\n\tbar.style.left    = tabLeft + 'px';\r\n\tbar.scrollLeft    = tabScrollLeft;\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------\r\n\r\n\r\nfunction onTableScroll(tab, head, cm) {\r\n\tconst sL = Math.max(0, Math.min(tab.scrollLeft, tab.scrollWidth - tab.offsetWidth));  // for iOS\r\n\thead.scrollLeft = sL;\r\n\r\n\tif (tab.scrollWidth - tab.clientWidth > 2) {  // for avoiding needless scrolling\r\n\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\r\n\t\tenableClass(r < 0.95, head, cm.styleScrollRight);\r\n\t\tenableClass(0.05 < r, head, cm.styleScrollLeft);\r\n\t} else {\r\n\t\tenableClass(false, head, cm.styleScrollRight);\r\n\t\tenableClass(false, head, cm.styleScrollLeft);\r\n\t}\r\n}\r\n\r\n\r\n// Utilities ---------------------------------------------------------------\r\n\r\n\r\nfunction getSelector(cls) {\r\n\tif (cls.startsWith(':')) {\r\n\t\treturn `*[data-${cls.substr(1).replace(/([A-Z])/g, c => '-' + c.charAt(0).toLowerCase())}]`;\r\n\t} else {\r\n\t\treturn `*${cls}`;\r\n\t}\r\n}\r\n\r\nfunction getScrollBarWidth(parent) {\r\n\tconst d = document.createElement('div');\r\n\td.setAttribute('style', 'position:absolute;bottom:100%;width:calc(100vw - 100%);height:1px;');\r\n\tparent.appendChild(d);\r\n\tlet width = 0 | window.getComputedStyle(d).getPropertyValue('width');\r\n\r\n\tif (width === 0) {  // Window does not have any scroll bar\r\n\t\td.style.overflowY = 'scroll';\r\n\t\td.style.width = '';\r\n\t\tconst c = document.createElement('div');\r\n\t\tc.style.minHeight = '100px';\r\n\t\td.appendChild(c);\r\n\t\tconst cw = 0 | window.getComputedStyle(c).getPropertyValue('width');\r\n\t\twidth = d.offsetWidth - cw;\r\n\t}\r\n\tparent.removeChild(d);\r\n\treturn width;\r\n}"]}