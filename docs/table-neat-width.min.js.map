{"version":3,"sources":["table-neat-width.js","_neat-width.js"],"names":["window","NACSS","NS","makeDummyCell","t","tagName","d","document","createElement","style","display","position","visibility","whiteSpace","appendChild","apply","tab","cMet","rows","length","maxRowSize","cellMinWidth","cellMinAspect","tr","hasChildNodes","n","childNodes","tn","parseInt","getAttribute","cw","clientWidth","ch","clientHeight","isResizeNeeded","hasAttribute","removeAttribute","width","maxWidth","grid","css","cs","push","collectCells","Math","max","g","Array","y","gr","tds","i","x","td","col","row","p","q","nr","makeCellGrid","ws","gc","w","HTMLTableCellElement","minWidth","setCellWidth","met","gw","newWs","fill","wrapped","gridRow","minW","wp","calcMinWidth","origTabW","origCellWs","wNew","wFix","rem","nw","min","widenTabWidth","calcNewWidths","Object","assign","getMetrics","padH","padV","charW","lineH","dcTd","dcTh","cellMinLength","ih","innerHTML","trim","ls","split","ts","map","e","replace","calcMaxLineLength","dc","aw","round","tempW","tempH","tableNeatWidth","tabs","opts","lt","cm","getElementsByTagName","s","getComputedStyle","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","elm","temp","nodeName","setAttribute","fontFamily","fontSize","parentNode","h","removeChild","getTextSize","getCommonMetrics","nnwMinWidthRate","maxBorderWidth","pw","parentElement"],"mappings":"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","file":"table-neat-width.min.js","sourcesContent":["/**\n *\n * Table Style - Neat Width (JS)\n *\n * @author Takuto Yanagida\n * @version 2021-01-04\n *\n */\n\n\nwindow.NACSS = window['NACSS'] || {};\n\n\n(function (NS) {\n\n\t/**\n\t *\n\t * Neat Width\n\t *\n\t * @author Takuto Yanagida\n\t * @version 2021-01-04\n\t *\n\t */\n\t\n\t\n\tfunction initialize(tabs, opts = {}) {\n\t\tif (tabs.length === 0) return;\n\t\tconst lt = tabs[tabs.length - 1];\n\t\tconst cm = Object.assign(opts, getCommonMetrics(lt), {\n\t\t\tnnwMinWidthRate : 0.1,\n\t\t\tcellMinWidth    : 100,\n\t\t\tcellMinAspect   : 2 / 3,  // width / height\n\t\t\tcellMinLength   : 8,\n\t\t\tmaxRowSize      : 200,\n\t\t\tmaxBorderWidth  : 2,\n\t\t});\n\t\tcm.padH += cm.maxBorderWidth * 2;\n\t\tcm.padV += cm.maxBorderWidth * 2;\n\t\tcm.dcTd = makeDummyCell(lt, 'td');\n\t\tcm.dcTh = makeDummyCell(lt, 'th');\n\t\tfor (const t of tabs) {\n\t\t\tif (!apply(t, cm) && cm.nnwMinWidthRate) {\n\t\t\t\tconst pw = t.parentElement.clientWidth;\n\t\t\t\tconst w  = t.clientWidth;\n\t\t\t\tif (pw - w < w * cm.nnwMinWidthRate) t.style.width = '100%';\n\t\t\t}\n\t\t}\n\t\tlt.removeChild(cm.dcTd);\n\t\tlt.removeChild(cm.dcTh);\n\t}\n\t\n\tfunction makeDummyCell(t, tagName) {\n\t\tconst d = document.createElement(tagName);\n\t\td.style.display    = 'inline-block';\n\t\td.style.position   = 'fixed';\n\t\td.style.visibility = 'hidden';\n\t\td.style.whiteSpace = 'nowrap';\n\t\treturn t.appendChild(d);\n\t}\n\t\n\tfunction getCommonMetrics(tab) {\n\t\tconst td = tab.getElementsByTagName('td')[0];\n\t\tconst s = getComputedStyle(td);\n\t\tconst padH  = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);\n\t\tconst padV  = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);\n\t\tconst [charW, lineH] = getTextSize(td);\n\t\treturn { padH, padV, charW, lineH };\n\t}\n\t\n\tfunction getTextSize(elm) {\n\t\tconst temp = document.createElement(elm.nodeName);\n\t\ttemp.setAttribute('style', `position:fixed;margin:0;padding:0;font-family:${elm.style.fontFamily || 'inherit'};font-size:${elm.style.fontSize || 'inherit'};`);\n\t\ttemp.innerHTML = '\\u3000';  // Full width space\n\t\telm.parentNode.appendChild(temp);\n\t\tconst w = temp.clientWidth;\n\t\tconst h = temp.clientHeight;\n\t\ttemp.parentNode.removeChild(temp);\n\t\treturn [w, h];\n\t}\n\t\n\tfunction apply(tab, cMet) {\n\t\tif (tab.rows.length === 0) return false;\n\t\tif (cMet.maxRowSize < tab.rows.length) return false;\n\t\tif (!isResizeNeeded(tab, cMet)) return false;\n\t\n\t\tif (tab.hasAttribute('width')) tab.removeAttribute('width');\n\t\ttab.style.width    = '';\n\t\ttab.style.maxWidth = '';\n\t\n\t\tconst grid  = makeCellGrid(tab);\n\t\tconst met   = Object.assign(getMetrics(tab, grid), cMet);\n\t\tconst newWs = calcNewWidths(grid, met);\n\t\tsetCellWidth(grid, newWs);\n\t\treturn true;\n\t}\n\t\n\tfunction isResizeNeeded(tab, cMet) {\n\t\tconst { cellMinWidth, cellMinAspect } = cMet;\n\t\tfor (const tr of tab.rows) {\n\t\t\tif (!tr.hasChildNodes()) continue;\n\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\tconst tn = n.tagName;\n\t\t\t\tif (tn !== 'TD' && tn !== 'TH') continue;\n\t\t\t\tif (1 < parseInt(n.getAttribute('colSpan'), 10)) continue;\n\t\t\t\tif (1 < parseInt(n.getAttribute('rowSpan'), 10)) continue;\n\t\t\t\tconst cw = n.clientWidth;\n\t\t\t\tconst ch = n.clientHeight;\n\t\t\t\tif (cw < cellMinWidth || cw / ch < cellMinAspect) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction makeCellGrid(t) {\n\t\tconst css = collectCells(t);\n\t\tlet maxWidth = 0;\n\t\tfor (const cs of css) maxWidth = Math.max(maxWidth, cs.length);\n\t\tconst g = [];\n\t\tfor (const cs of css) g.push(new Array(maxWidth));\n\t\n\t\tfor (let y = 0; y < g.length; y += 1) {\n\t\t\tconst gr = g[y];\n\t\t\tconst tds = css[y];\n\t\t\tlet i = 0;\n\t\n\t\t\tfor (let x = 0; x < maxWidth; x += 1) {\n\t\t\t\tif (typeof gr[x] === 'number' || gr[x] === null) continue;\n\t\n\t\t\t\tconst td = tds[i]\n\t\t\t\tconst col = parseInt(td.getAttribute('colSpan') ?? 1, 10);\n\t\t\t\tconst row = parseInt(td.getAttribute('rowSpan') ?? 1, 10);\n\t\t\t\tgr[x] = td;\n\t\n\t\t\t\tif (1 < col) {\n\t\t\t\t\tfor (let p = 1; p < col; p += 1) gr[x + p] = p;\n\t\t\t\t}\n\t\t\t\tif (1 < row) {\n\t\t\t\t\tfor (let q = 1; q < row; q += 1) {\n\t\t\t\t\t\tconst nr = g[y + q];\n\t\t\t\t\t\tfor (let p = 0; p < col; p += 1) nr[x + p] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ti += 1;\n\t\t\t\tif (tds.length <= i) break;\n\t\t\t}\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tfunction collectCells(t, css = []) {\n\t\tfor (const tr of t.rows) {\n\t\t\tconst cs = [];\n\t\t\tif (tr.hasChildNodes()) {\n\t\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\t\tconst tn = n.tagName;\n\t\t\t\t\tif (tn === 'TD' || tn === 'TH') cs.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcss.push(cs);\n\t\t}\n\t\treturn css;\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction getMetrics(tab, grid) {\n\t\tconst origTabW = tab.clientWidth;\n\t\tconst origCellWs = [];\n\t\tfor (let x = 0; x < grid[0].length; x += 1) {\n\t\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\t\tconst g = grid[y][x];\n\t\t\t\tif (g instanceof HTMLTableCellElement && !g.getAttribute('colSpan')) {\n\t\t\t\t\torigCellWs.push(g.clientWidth);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { origTabW, origCellWs };\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction calcNewWidths(grid, met) {\n\t\tfor (const gr of grid) {\n\t\t\tfor (const gc of gr) {\n\t\t\t\tif (typeof gc !== 'number' && gc !== null) gc.style.whiteSpace = 'nowrap';\n\t\t\t}\n\t\t}\n\t\tconst gw = grid[0].length;\n\t\tconst newWs = new Array(gw).fill(false);\n\t\tconst wrapped = new Array(gw).fill(false);\n\t\n\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\tconst gridRow = grid[y];\n\t\n\t\t\tfor (let x = 0; x < gw; x += 1) {\n\t\t\t\tconst td = gridRow[x];\n\t\t\t\tif (td === undefined || td === null || typeof td === 'number') continue;\n\t\t\t\tif (x < gw - 1 && typeof gridRow[x + 1] === 'number') continue;\n\t\t\t\tif (1 < parseInt(td.getAttribute('colSpan'), 10)) continue;\n\t\t\t\tif (1 < parseInt(td.getAttribute('rowSpan'), 10)) continue;\n\t\n\t\t\t\tconst [minW, wp] = calcMinWidth(td, met);\n\t\t\t\tif (minW) newWs[x] = Math.max(newWs[x], minW);\n\t\t\t\tif (wp) wrapped[x] = wp;\n\t\t\t}\n\t\t}\n\t\twidenTabWidth(newWs, wrapped, met);\n\t\treturn newWs;\n\t}\n\t\n\tfunction calcMinWidth(td, met) {\n\t\tconst { padH, padV, charW, lineH, cellMinWidth, dcTd, dcTh, cellMinAspect, cellMinLength } = met;\n\t\tif (calcMaxLineLength(td) < cellMinLength) return [0, false];\n\t\n\t\ttd.innerHTML = td.innerHTML.trim();\n\t\tconst dc = td.tagName === 'TD' ? dcTd : dcTh;\n\t\tdc.innerHTML = td.innerHTML;\n\t\tconst aw = dc.clientWidth - padH;\n\t\tconst ls = Math.round((dc.clientHeight - padV) / lineH);\n\t\tlet minW = 0, wrapped = false;\n\t\tfor (let i = 1; ; i += 1) {\n\t\t\tconst tempW = 0 | (aw / i + charW * i + padH);\n\t\t\tconst tempH = ls * (i * lineH) + padV;\n\t\t\tif (tempW < cellMinWidth || tempW / tempH < cellMinAspect || (minW && minW < tempW)) break;\n\t\t\tif (1 < i) wrapped = true;\n\t\t\tminW = tempW;\n\t\t}\n\t\treturn [minW, wrapped];\n\t}\n\t\n\tfunction calcMaxLineLength(td) {\n\t\tconst ih = td.innerHTML.trim();\n\t\tlet ls = ih.split(/<\\s*br\\s*\\/?>/ui);\n\t\tif (ls.length === 0) ls = [ih];\n\t\tconst ts = ls.map(e => e.replace(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/g, '').length);\n\t\treturn Math.max(...ts);\n\t}\n\t\n\tfunction widenTabWidth(newWs, wrapped, met) {\n\t\tconst { origTabW, origCellWs } = met;\n\t\tlet wNew = 0, wFix = 0;\n\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\tif (wrapped[i]) {\n\t\t\t\twNew += newWs[i];\n\t\t\t} else if (newWs[i]) {\n\t\t\t\twFix += newWs[i];\n\t\t\t} else {\n\t\t\t\twFix += origCellWs[i];\n\t\t\t}\n\t\t}\n\t\tif (origTabW < wNew + wFix) return;\n\t\tlet rem = origTabW - wFix;\n\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\tif (!wrapped[i]) continue;\n\t\t\tconst nw = newWs[i];\n\t\t\tconst w = Math.min(nw / wNew * rem, origCellWs[i]);\n\t\t\trem  -= (w - nw);\n\t\t\twNew -= (w - nw);\n\t\t\tnewWs[i] = 0 | w;\n\t\t}\n\t}\n\t\n\t\n\t// -------------------------------------------------------------------------\n\t\n\t\n\tfunction setCellWidth(grid, ws) {\n\t\tfor (const gr of grid) {\n\t\t\tfor (let x = 0; x < gr.length; x += 1) {\n\t\t\t\tconst gc = gr[x], w = ws[x];\n\t\t\t\tif (w === false || !(gc instanceof HTMLTableCellElement)) continue;\n\t\t\t\tgc.style.whiteSpace = null;\n\t\t\t\tgc.style.minWidth   = w + 'px';\n\t\t\t\tgc.style.width      = null;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tNS.tableNeatWidth = initialize;\n\n})(window.NACSS);\n","/**\n *\n * Neat Width\n *\n * @author Takuto Yanagida\n * @version 2021-01-04\n *\n */\n\n\nfunction initialize(tabs, opts = {}) {\n\tif (tabs.length === 0) return;\n\tconst lt = tabs[tabs.length - 1];\n\tconst cm = Object.assign(opts, getCommonMetrics(lt), {\n\t\tnnwMinWidthRate : 0.1,\n\t\tcellMinWidth    : 100,\n\t\tcellMinAspect   : 2 / 3,  // width / height\n\t\tcellMinLength   : 8,\n\t\tmaxRowSize      : 200,\n\t\tmaxBorderWidth  : 2,\n\t});\n\tcm.padH += cm.maxBorderWidth * 2;\n\tcm.padV += cm.maxBorderWidth * 2;\n\tcm.dcTd = makeDummyCell(lt, 'td');\n\tcm.dcTh = makeDummyCell(lt, 'th');\n\tfor (const t of tabs) {\n\t\tif (!apply(t, cm) && cm.nnwMinWidthRate) {\n\t\t\tconst pw = t.parentElement.clientWidth;\n\t\t\tconst w  = t.clientWidth;\n\t\t\tif (pw - w < w * cm.nnwMinWidthRate) t.style.width = '100%';\n\t\t}\n\t}\n\tlt.removeChild(cm.dcTd);\n\tlt.removeChild(cm.dcTh);\n}\n\nfunction makeDummyCell(t, tagName) {\n\tconst d = document.createElement(tagName);\n\td.style.display    = 'inline-block';\n\td.style.position   = 'fixed';\n\td.style.visibility = 'hidden';\n\td.style.whiteSpace = 'nowrap';\n\treturn t.appendChild(d);\n}\n\nfunction getCommonMetrics(tab) {\n\tconst td = tab.getElementsByTagName('td')[0];\n\tconst s = getComputedStyle(td);\n\tconst padH  = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);\n\tconst padV  = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);\n\tconst [charW, lineH] = getTextSize(td);\n\treturn { padH, padV, charW, lineH };\n}\n\nfunction getTextSize(elm) {\n\tconst temp = document.createElement(elm.nodeName);\n\ttemp.setAttribute('style', `position:fixed;margin:0;padding:0;font-family:${elm.style.fontFamily || 'inherit'};font-size:${elm.style.fontSize || 'inherit'};`);\n\ttemp.innerHTML = '\\u3000';  // Full width space\n\telm.parentNode.appendChild(temp);\n\tconst w = temp.clientWidth;\n\tconst h = temp.clientHeight;\n\ttemp.parentNode.removeChild(temp);\n\treturn [w, h];\n}\n\nfunction apply(tab, cMet) {\n\tif (tab.rows.length === 0) return false;\n\tif (cMet.maxRowSize < tab.rows.length) return false;\n\tif (!isResizeNeeded(tab, cMet)) return false;\n\n\tif (tab.hasAttribute('width')) tab.removeAttribute('width');\n\ttab.style.width    = '';\n\ttab.style.maxWidth = '';\n\n\tconst grid  = makeCellGrid(tab);\n\tconst met   = Object.assign(getMetrics(tab, grid), cMet);\n\tconst newWs = calcNewWidths(grid, met);\n\tsetCellWidth(grid, newWs);\n\treturn true;\n}\n\nfunction isResizeNeeded(tab, cMet) {\n\tconst { cellMinWidth, cellMinAspect } = cMet;\n\tfor (const tr of tab.rows) {\n\t\tif (!tr.hasChildNodes()) continue;\n\t\tfor (const n of tr.childNodes) {\n\t\t\tconst tn = n.tagName;\n\t\t\tif (tn !== 'TD' && tn !== 'TH') continue;\n\t\t\tif (1 < parseInt(n.getAttribute('colSpan'), 10)) continue;\n\t\t\tif (1 < parseInt(n.getAttribute('rowSpan'), 10)) continue;\n\t\t\tconst cw = n.clientWidth;\n\t\t\tconst ch = n.clientHeight;\n\t\t\tif (cw < cellMinWidth || cw / ch < cellMinAspect) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction makeCellGrid(t) {\n\tconst css = collectCells(t);\n\tlet maxWidth = 0;\n\tfor (const cs of css) maxWidth = Math.max(maxWidth, cs.length);\n\tconst g = [];\n\tfor (const cs of css) g.push(new Array(maxWidth));\n\n\tfor (let y = 0; y < g.length; y += 1) {\n\t\tconst gr = g[y];\n\t\tconst tds = css[y];\n\t\tlet i = 0;\n\n\t\tfor (let x = 0; x < maxWidth; x += 1) {\n\t\t\tif (typeof gr[x] === 'number' || gr[x] === null) continue;\n\n\t\t\tconst td = tds[i]\n\t\t\tconst col = parseInt(td.getAttribute('colSpan') ?? 1, 10);\n\t\t\tconst row = parseInt(td.getAttribute('rowSpan') ?? 1, 10);\n\t\t\tgr[x] = td;\n\n\t\t\tif (1 < col) {\n\t\t\t\tfor (let p = 1; p < col; p += 1) gr[x + p] = p;\n\t\t\t}\n\t\t\tif (1 < row) {\n\t\t\t\tfor (let q = 1; q < row; q += 1) {\n\t\t\t\t\tconst nr = g[y + q];\n\t\t\t\t\tfor (let p = 0; p < col; p += 1) nr[x + p] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += 1;\n\t\t\tif (tds.length <= i) break;\n\t\t}\n\t}\n\treturn g;\n}\n\nfunction collectCells(t, css = []) {\n\tfor (const tr of t.rows) {\n\t\tconst cs = [];\n\t\tif (tr.hasChildNodes()) {\n\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\tconst tn = n.tagName;\n\t\t\t\tif (tn === 'TD' || tn === 'TH') cs.push(n);\n\t\t\t}\n\t\t}\n\t\tcss.push(cs);\n\t}\n\treturn css;\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction getMetrics(tab, grid) {\n\tconst origTabW = tab.clientWidth;\n\tconst origCellWs = [];\n\tfor (let x = 0; x < grid[0].length; x += 1) {\n\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\tconst g = grid[y][x];\n\t\t\tif (g instanceof HTMLTableCellElement && !g.getAttribute('colSpan')) {\n\t\t\t\torigCellWs.push(g.clientWidth);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn { origTabW, origCellWs };\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction calcNewWidths(grid, met) {\n\tfor (const gr of grid) {\n\t\tfor (const gc of gr) {\n\t\t\tif (typeof gc !== 'number' && gc !== null) gc.style.whiteSpace = 'nowrap';\n\t\t}\n\t}\n\tconst gw = grid[0].length;\n\tconst newWs = new Array(gw).fill(false);\n\tconst wrapped = new Array(gw).fill(false);\n\n\tfor (let y = 0; y < grid.length; y += 1) {\n\t\tconst gridRow = grid[y];\n\n\t\tfor (let x = 0; x < gw; x += 1) {\n\t\t\tconst td = gridRow[x];\n\t\t\tif (td === undefined || td === null || typeof td === 'number') continue;\n\t\t\tif (x < gw - 1 && typeof gridRow[x + 1] === 'number') continue;\n\t\t\tif (1 < parseInt(td.getAttribute('colSpan'), 10)) continue;\n\t\t\tif (1 < parseInt(td.getAttribute('rowSpan'), 10)) continue;\n\n\t\t\tconst [minW, wp] = calcMinWidth(td, met);\n\t\t\tif (minW) newWs[x] = Math.max(newWs[x], minW);\n\t\t\tif (wp) wrapped[x] = wp;\n\t\t}\n\t}\n\twidenTabWidth(newWs, wrapped, met);\n\treturn newWs;\n}\n\nfunction calcMinWidth(td, met) {\n\tconst { padH, padV, charW, lineH, cellMinWidth, dcTd, dcTh, cellMinAspect, cellMinLength } = met;\n\tif (calcMaxLineLength(td) < cellMinLength) return [0, false];\n\n\ttd.innerHTML = td.innerHTML.trim();\n\tconst dc = td.tagName === 'TD' ? dcTd : dcTh;\n\tdc.innerHTML = td.innerHTML;\n\tconst aw = dc.clientWidth - padH;\n\tconst ls = Math.round((dc.clientHeight - padV) / lineH);\n\tlet minW = 0, wrapped = false;\n\tfor (let i = 1; ; i += 1) {\n\t\tconst tempW = 0 | (aw / i + charW * i + padH);\n\t\tconst tempH = ls * (i * lineH) + padV;\n\t\tif (tempW < cellMinWidth || tempW / tempH < cellMinAspect || (minW && minW < tempW)) break;\n\t\tif (1 < i) wrapped = true;\n\t\tminW = tempW;\n\t}\n\treturn [minW, wrapped];\n}\n\nfunction calcMaxLineLength(td) {\n\tconst ih = td.innerHTML.trim();\n\tlet ls = ih.split(/<\\s*br\\s*\\/?>/ui);\n\tif (ls.length === 0) ls = [ih];\n\tconst ts = ls.map(e => e.replace(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/g, '').length);\n\treturn Math.max(...ts);\n}\n\nfunction widenTabWidth(newWs, wrapped, met) {\n\tconst { origTabW, origCellWs } = met;\n\tlet wNew = 0, wFix = 0;\n\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\tif (wrapped[i]) {\n\t\t\twNew += newWs[i];\n\t\t} else if (newWs[i]) {\n\t\t\twFix += newWs[i];\n\t\t} else {\n\t\t\twFix += origCellWs[i];\n\t\t}\n\t}\n\tif (origTabW < wNew + wFix) return;\n\tlet rem = origTabW - wFix;\n\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\tif (!wrapped[i]) continue;\n\t\tconst nw = newWs[i];\n\t\tconst w = Math.min(nw / wNew * rem, origCellWs[i]);\n\t\trem  -= (w - nw);\n\t\twNew -= (w - nw);\n\t\tnewWs[i] = 0 | w;\n\t}\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction setCellWidth(grid, ws) {\n\tfor (const gr of grid) {\n\t\tfor (let x = 0; x < gr.length; x += 1) {\n\t\t\tconst gc = gr[x], w = ws[x];\n\t\t\tif (w === false || !(gc instanceof HTMLTableCellElement)) continue;\n\t\t\tgc.style.whiteSpace = null;\n\t\t\tgc.style.minWidth   = w + 'px';\n\t\t\tgc.style.width      = null;\n\t\t}\n\t}\n}\n"]}