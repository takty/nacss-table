{"version":3,"sources":["table.js","_neat-width.js","_fixed-header.js"],"names":["window","NACSS","NS","makeDummyCell","t","tagName","d","document","createElement","style","display","position","visibility","whiteSpace","appendChild","apply","tab","cMet","rows","length","maxRowSize","cellMinWidth","cellMinAspect","tr","hasChildNodes","n","childNodes","tn","parseInt","getAttribute","cw","clientWidth","ch","clientHeight","isResizeNeeded","hasAttribute","removeAttribute","width","maxWidth","grid","css","cs","push","collectCells","Math","max","g","Array","y","gr","tds","i","x","td","col","row","p","q","nr","makeCellGrid","ws","gc","w","HTMLTableCellElement","minWidth","setCellWidth","met","gw","newWs","fill","wrapped","gridRow","minW","wp","calcMinWidth","origTabW","origCellWs","wNew","wFix","rem","nw","min","widenTabWidth","calcNewWidths","Object","assign","getMetrics","padH","padV","charW","lineH","dcTd","dcTh","cellMinLength","ih","innerHTML","trim","ls","split","ts","map","e","replace","calcMaxLineLength","dc","aw","round","tempW","tempH","tableNeatWidth","tabs","opts","lt","cm","getElementsByTagName","s","getComputedStyle","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","elm","temp","nodeName","setAttribute","fontFamily","fontSize","parentNode","h","removeChild","getTextSize","getCommonMetrics","nnwMinWidthRate","maxBorderWidth","pw","parentElement","ST_STATE_ENLARGED","getOffset","scrollBarWidth","FixedHeaderTable","constructor","height","this","_table","_headerHeight","_isEnlarged","_windowWidth","outerWidth","innerWidth","_create","setTimeout","_initialize","_head","_createHeaderClone","_sbar","_createScrollBarClone","_ebtn","containStile","_createEnlargerButton","_shade","_createShade","caps","_capt","thead","tHead","_createPseudoHeader","cont","addStile","ptab","clone","cloneNode","trs","tBodies","containsOnlyTh","ths","trsH","I","createTHead","sbar","spacer","ebtn","dataset","shade","bg","backgroundColor","_initTableScroll","addEventListener","_turnOffEnlarged","_turnOnEnlarged","_isEnlargable","_resize","_adjustUnexpectedScrollBar","tableScrollChanged","sbarScrollChanged","throttle","scrollLeft","_onTableScroll","_isScrollable","scrollWidth","ww","offsetWidth","left","getBoundingClientRect","pageXOffset","pwidth","marginLeft","background","removeStile","onWindowResize","overflowX","_updateHeaderSize","_updateScrollBarSize","onWindowScroll","top","firstChild","oTrs","cTrs","copyWidth","o","c","tag","os","_getScrollBarWidth","tbody","ceil","tabTop","tabBottom","bottom","offset","capH","offsetHeight","headH","inView","innerHeight","headVisible","sbarVisible","updateHeaderVisibility","updateScrollBarVisibility","visible","tabLeft","head","switchEnlargerToFloatingHeader","switchEnlargerToTable","capt","sL","_stCapt","clearTimeout","transform","_stEbtn","_updateEnlager","_stShade","_updateShade","scrW","cltW","etbRight","diff","right","_calcShadeStyle","r","rl","rr","sl","sr","dummy","body","getPropertyValue","overflowY","minHeight","tableFixedHeader","conts","onScroll","onResize"],"mappings":"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","file":"table.min.js","sourcesContent":["/**\n *\n * Table Style (JS)\n *\n * @author Takuto Yanagida\n * @version 2021-01-04\n *\n */\n\n\nwindow.NACSS = window['NACSS'] || {};\n\n\n(function (NS) {\n\n\t(function () {\n\t\t/**\n\t\t *\n\t\t * Neat Width\n\t\t *\n\t\t * @author Takuto Yanagida\n\t\t * @version 2021-01-04\n\t\t *\n\t\t */\n\t\t\n\t\t\n\t\tfunction initialize(tabs, opts = {}) {\n\t\t\tif (tabs.length === 0) return;\n\t\t\tconst lt = tabs[tabs.length - 1];\n\t\t\tconst cm = Object.assign(opts, getCommonMetrics(lt), {\n\t\t\t\tnnwMinWidthRate : 0.1,\n\t\t\t\tcellMinWidth    : 100,\n\t\t\t\tcellMinAspect   : 2 / 3,  // width / height\n\t\t\t\tcellMinLength   : 8,\n\t\t\t\tmaxRowSize      : 200,\n\t\t\t\tmaxBorderWidth  : 2,\n\t\t\t});\n\t\t\tcm.padH += cm.maxBorderWidth * 2;\n\t\t\tcm.padV += cm.maxBorderWidth * 2;\n\t\t\tcm.dcTd = makeDummyCell(lt, 'td');\n\t\t\tcm.dcTh = makeDummyCell(lt, 'th');\n\t\t\tfor (const t of tabs) {\n\t\t\t\tif (!apply(t, cm) && cm.nnwMinWidthRate) {\n\t\t\t\t\tconst pw = t.parentElement.clientWidth;\n\t\t\t\t\tconst w  = t.clientWidth;\n\t\t\t\t\tif (pw - w < w * cm.nnwMinWidthRate) t.style.width = '100%';\n\t\t\t\t}\n\t\t\t}\n\t\t\tlt.removeChild(cm.dcTd);\n\t\t\tlt.removeChild(cm.dcTh);\n\t\t}\n\t\t\n\t\tfunction makeDummyCell(t, tagName) {\n\t\t\tconst d = document.createElement(tagName);\n\t\t\td.style.display    = 'inline-block';\n\t\t\td.style.position   = 'fixed';\n\t\t\td.style.visibility = 'hidden';\n\t\t\td.style.whiteSpace = 'nowrap';\n\t\t\treturn t.appendChild(d);\n\t\t}\n\t\t\n\t\tfunction getCommonMetrics(tab) {\n\t\t\tconst td = tab.getElementsByTagName('td')[0];\n\t\t\tconst s = getComputedStyle(td);\n\t\t\tconst padH  = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);\n\t\t\tconst padV  = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);\n\t\t\tconst [charW, lineH] = getTextSize(td);\n\t\t\treturn { padH, padV, charW, lineH };\n\t\t}\n\t\t\n\t\tfunction getTextSize(elm) {\n\t\t\tconst temp = document.createElement(elm.nodeName);\n\t\t\ttemp.setAttribute('style', `position:fixed;margin:0;padding:0;font-family:${elm.style.fontFamily || 'inherit'};font-size:${elm.style.fontSize || 'inherit'};`);\n\t\t\ttemp.innerHTML = '\\u3000';  // Full width space\n\t\t\telm.parentNode.appendChild(temp);\n\t\t\tconst w = temp.clientWidth;\n\t\t\tconst h = temp.clientHeight;\n\t\t\ttemp.parentNode.removeChild(temp);\n\t\t\treturn [w, h];\n\t\t}\n\t\t\n\t\tfunction apply(tab, cMet) {\n\t\t\tif (tab.rows.length === 0) return false;\n\t\t\tif (cMet.maxRowSize < tab.rows.length) return false;\n\t\t\tif (!isResizeNeeded(tab, cMet)) return false;\n\t\t\n\t\t\tif (tab.hasAttribute('width')) tab.removeAttribute('width');\n\t\t\ttab.style.width    = '';\n\t\t\ttab.style.maxWidth = '';\n\t\t\n\t\t\tconst grid  = makeCellGrid(tab);\n\t\t\tconst met   = Object.assign(getMetrics(tab, grid), cMet);\n\t\t\tconst newWs = calcNewWidths(grid, met);\n\t\t\tsetCellWidth(grid, newWs);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tfunction isResizeNeeded(tab, cMet) {\n\t\t\tconst { cellMinWidth, cellMinAspect } = cMet;\n\t\t\tfor (const tr of tab.rows) {\n\t\t\t\tif (!tr.hasChildNodes()) continue;\n\t\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\t\tconst tn = n.tagName;\n\t\t\t\t\tif (tn !== 'TD' && tn !== 'TH') continue;\n\t\t\t\t\tif (1 < parseInt(n.getAttribute('colSpan'), 10)) continue;\n\t\t\t\t\tif (1 < parseInt(n.getAttribute('rowSpan'), 10)) continue;\n\t\t\t\t\tconst cw = n.clientWidth;\n\t\t\t\t\tconst ch = n.clientHeight;\n\t\t\t\t\tif (cw < cellMinWidth || cw / ch < cellMinAspect) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction makeCellGrid(t) {\n\t\t\tconst css = collectCells(t);\n\t\t\tlet maxWidth = 0;\n\t\t\tfor (const cs of css) maxWidth = Math.max(maxWidth, cs.length);\n\t\t\tconst g = [];\n\t\t\tfor (const cs of css) g.push(new Array(maxWidth));\n\t\t\n\t\t\tfor (let y = 0; y < g.length; y += 1) {\n\t\t\t\tconst gr = g[y];\n\t\t\t\tconst tds = css[y];\n\t\t\t\tlet i = 0;\n\t\t\n\t\t\t\tfor (let x = 0; x < maxWidth; x += 1) {\n\t\t\t\t\tif (typeof gr[x] === 'number' || gr[x] === null) continue;\n\t\t\n\t\t\t\t\tconst td = tds[i]\n\t\t\t\t\tconst col = parseInt(td.getAttribute('colSpan') ?? 1, 10);\n\t\t\t\t\tconst row = parseInt(td.getAttribute('rowSpan') ?? 1, 10);\n\t\t\t\t\tgr[x] = td;\n\t\t\n\t\t\t\t\tif (1 < col) {\n\t\t\t\t\t\tfor (let p = 1; p < col; p += 1) gr[x + p] = p;\n\t\t\t\t\t}\n\t\t\t\t\tif (1 < row) {\n\t\t\t\t\t\tfor (let q = 1; q < row; q += 1) {\n\t\t\t\t\t\t\tconst nr = g[y + q];\n\t\t\t\t\t\t\tfor (let p = 0; p < col; p += 1) nr[x + p] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t\tif (tds.length <= i) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\t\n\t\tfunction collectCells(t, css = []) {\n\t\t\tfor (const tr of t.rows) {\n\t\t\t\tconst cs = [];\n\t\t\t\tif (tr.hasChildNodes()) {\n\t\t\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\t\t\tconst tn = n.tagName;\n\t\t\t\t\t\tif (tn === 'TD' || tn === 'TH') cs.push(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcss.push(cs);\n\t\t\t}\n\t\t\treturn css;\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction getMetrics(tab, grid) {\n\t\t\tconst origTabW = tab.clientWidth;\n\t\t\tconst origCellWs = [];\n\t\t\tfor (let x = 0; x < grid[0].length; x += 1) {\n\t\t\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\t\t\tconst g = grid[y][x];\n\t\t\t\t\tif (g instanceof HTMLTableCellElement && !g.getAttribute('colSpan')) {\n\t\t\t\t\t\torigCellWs.push(g.clientWidth);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { origTabW, origCellWs };\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction calcNewWidths(grid, met) {\n\t\t\tfor (const gr of grid) {\n\t\t\t\tfor (const gc of gr) {\n\t\t\t\t\tif (typeof gc !== 'number' && gc !== null) gc.style.whiteSpace = 'nowrap';\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst gw = grid[0].length;\n\t\t\tconst newWs = new Array(gw).fill(false);\n\t\t\tconst wrapped = new Array(gw).fill(false);\n\t\t\n\t\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\t\tconst gridRow = grid[y];\n\t\t\n\t\t\t\tfor (let x = 0; x < gw; x += 1) {\n\t\t\t\t\tconst td = gridRow[x];\n\t\t\t\t\tif (td === undefined || td === null || typeof td === 'number') continue;\n\t\t\t\t\tif (x < gw - 1 && typeof gridRow[x + 1] === 'number') continue;\n\t\t\t\t\tif (1 < parseInt(td.getAttribute('colSpan'), 10)) continue;\n\t\t\t\t\tif (1 < parseInt(td.getAttribute('rowSpan'), 10)) continue;\n\t\t\n\t\t\t\t\tconst [minW, wp] = calcMinWidth(td, met);\n\t\t\t\t\tif (minW) newWs[x] = Math.max(newWs[x], minW);\n\t\t\t\t\tif (wp) wrapped[x] = wp;\n\t\t\t\t}\n\t\t\t}\n\t\t\twidenTabWidth(newWs, wrapped, met);\n\t\t\treturn newWs;\n\t\t}\n\t\t\n\t\tfunction calcMinWidth(td, met) {\n\t\t\tconst { padH, padV, charW, lineH, cellMinWidth, dcTd, dcTh, cellMinAspect, cellMinLength } = met;\n\t\t\tif (calcMaxLineLength(td) < cellMinLength) return [0, false];\n\t\t\n\t\t\ttd.innerHTML = td.innerHTML.trim();\n\t\t\tconst dc = td.tagName === 'TD' ? dcTd : dcTh;\n\t\t\tdc.innerHTML = td.innerHTML;\n\t\t\tconst aw = dc.clientWidth - padH;\n\t\t\tconst ls = Math.round((dc.clientHeight - padV) / lineH);\n\t\t\tlet minW = 0, wrapped = false;\n\t\t\tfor (let i = 1; ; i += 1) {\n\t\t\t\tconst tempW = 0 | (aw / i + charW * i + padH);\n\t\t\t\tconst tempH = ls * (i * lineH) + padV;\n\t\t\t\tif (tempW < cellMinWidth || tempW / tempH < cellMinAspect || (minW && minW < tempW)) break;\n\t\t\t\tif (1 < i) wrapped = true;\n\t\t\t\tminW = tempW;\n\t\t\t}\n\t\t\treturn [minW, wrapped];\n\t\t}\n\t\t\n\t\tfunction calcMaxLineLength(td) {\n\t\t\tconst ih = td.innerHTML.trim();\n\t\t\tlet ls = ih.split(/<\\s*br\\s*\\/?>/ui);\n\t\t\tif (ls.length === 0) ls = [ih];\n\t\t\tconst ts = ls.map(e => e.replace(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/g, '').length);\n\t\t\treturn Math.max(...ts);\n\t\t}\n\t\t\n\t\tfunction widenTabWidth(newWs, wrapped, met) {\n\t\t\tconst { origTabW, origCellWs } = met;\n\t\t\tlet wNew = 0, wFix = 0;\n\t\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\t\tif (wrapped[i]) {\n\t\t\t\t\twNew += newWs[i];\n\t\t\t\t} else if (newWs[i]) {\n\t\t\t\t\twFix += newWs[i];\n\t\t\t\t} else {\n\t\t\t\t\twFix += origCellWs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (origTabW < wNew + wFix) return;\n\t\t\tlet rem = origTabW - wFix;\n\t\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\t\tif (!wrapped[i]) continue;\n\t\t\t\tconst nw = newWs[i];\n\t\t\t\tconst w = Math.min(nw / wNew * rem, origCellWs[i]);\n\t\t\t\trem  -= (w - nw);\n\t\t\t\twNew -= (w - nw);\n\t\t\t\tnewWs[i] = 0 | w;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction setCellWidth(grid, ws) {\n\t\t\tfor (const gr of grid) {\n\t\t\t\tfor (let x = 0; x < gr.length; x += 1) {\n\t\t\t\t\tconst gc = gr[x], w = ws[x];\n\t\t\t\t\tif (w === false || !(gc instanceof HTMLTableCellElement)) continue;\n\t\t\t\t\tgc.style.whiteSpace = null;\n\t\t\t\t\tgc.style.minWidth   = w + 'px';\n\t\t\t\t\tgc.style.width      = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tNS.tableNeatWidth = initialize;\n\t})();\n\n\t(function () {\n\t\t/**\n\t\t *\n\t\t * Fixed Header (JS)\n\t\t *\n\t\t * @author Takuto Yanagida\n\t\t * @version 2021-01-04\n\t\t *\n\t\t */\n\t\t\n\t\t\n\t\tconst SEL_TARGET = '.stile';\n\t\t\n\t\tconst ST_HEADER_CONTAINER = 'fixed-table-header-container';\n\t\tconst ST_HEADER_TABLE     = 'fixed-table-header-table';\n\t\tconst ST_SCROLL_BAR       = 'fixed-table-scroll-bar';\n\t\tconst ST_ENLARGER_BUTTON  = 'enlarger-button';\n\t\tconst ST_TABLE_SHADE      = 'table-shade';\n\t\tconst ST_STATE_ENLARGED   = 'table-enlarged';\n\t\tconst ST_OPT_NO_ENLARGER  = 'no-enlarger';\n\t\t\n\t\tconst CAPABLE_WINDOW_HEIGHT_RATIO = 0.9;\n\t\tconst ENLARGER_WINDOW_WIDTH_RATIO = 0.9;\n\t\t\n\t\tlet getOffset;\n\t\tlet scrollBarWidth;\n\t\t\n\t\t// NS.addInit(4, () => {\n\t\t// \tgetOffset = NS.makeOffsetFunction(false, true);  // Initialize here\n\t\t\n\t\t// \tconst tabs = document.querySelectorAll(SEL_TARGET + ' table:not([class])');\n\t\t// \tsetTimeout(() => { initialize(tabs); }, 0);  // Delay for IE11\n\t\t// });\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction initialize(tabs) {\n\t\t\tscrollBarWidth = parseInt(_getScrollBarWidth());\n\t\t\tconst conts = [];\n\t\t\tfor (let i = 0; i < tabs.length; i += 1) conts.push(new FixedHeaderTable(tabs[i]));\n\t\t\tNS.onScroll(() => { for (let i = 0; i < conts.length; i += 1) conts[i].onWindowScroll(); });\n\t\t\tNS.onResize(() => { for (let i = 0; i < conts.length; i += 1) conts[i].onWindowResize(); });\n\t\t}\n\t\t\n\t\tclass FixedHeaderTable {\n\t\t\n\t\t\tconstructor (tab) {\n\t\t\t\tif (tab.style.height) tab.style.height = '';\n\t\t\t\tthis._table        = tab;\n\t\t\t\tthis._headerHeight = 0;\n\t\t\t\tthis._isEnlarged   = false;\n\t\t\t\tthis._windowWidth  = Math.min(window.outerWidth, window.innerWidth);  // for iOS\n\t\t\t\tthis._create();\n\t\t\t\tsetTimeout(() => { this._initialize(); }, 10);\n\t\t\t}\n\t\t\n\t\t\t_create() {\n\t\t\t\tthis._head = this._createHeaderClone();\n\t\t\t\tthis._sbar = this._createScrollBarClone();\n\t\t\t\tthis._ebtn = NS.containStile(this._table, ST_OPT_NO_ENLARGER) ? null : this._createEnlargerButton();\n\t\t\t\tthis._shade = this._createShade();\n\t\t\n\t\t\t\tconst caps = this._table.getElementsByTagName('caption');\n\t\t\t\tthis._capt = caps.length ? caps[0] : null;\n\t\t\t}\n\t\t\n\t\t\t_createHeaderClone() {\n\t\t\t\tlet thead = this._table.tHead;\n\t\t\t\tif (!thead) {\n\t\t\t\t\tthead = this._createPseudoHeader();\n\t\t\t\t\tif (!thead) return null;\n\t\t\t\t\tthis._table.tHead = thead;\n\t\t\t\t}\n\t\t\t\tconst cont = document.createElement('div');\n\t\t\t\tNS.addStile(cont, ST_HEADER_CONTAINER);\n\t\t\t\tthis._table.parentNode.appendChild(cont);\n\t\t\n\t\t\t\tconst ptab = document.createElement('div');\n\t\t\t\tNS.addStile(ptab, ST_HEADER_TABLE);\n\t\t\t\tcont.appendChild(ptab);\n\t\t\n\t\t\t\tconst clone = thead.cloneNode(true);\n\t\t\t\tptab.appendChild(clone);\n\t\t\n\t\t\t\tif (NS.containStile(this._table, ST_STATE_ENLARGED)) NS.addStile(cont, ST_STATE_ENLARGED);\n\t\t\t\treturn cont;\n\t\t\t}\n\t\t\n\t\t\t_createPseudoHeader() {\n\t\t\t\tconst tbody = this._table.tBodies[0];\n\t\t\t\tconst trs = tbody.rows;\n\t\t\t\tif (trs.length === 0) return null;\n\t\t\n\t\t\t\tfunction containsOnlyTh(tr) {\n\t\t\t\t\tconst tds = tr.getElementsByTagName('td');\n\t\t\t\t\tconst ths = tr.getElementsByTagName('th');\n\t\t\t\t\tif (tds.length === 0 && ths.length > 0) return true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\n\t\t\t\tconst trsH = [];\n\t\t\t\tfor (let i = 0, I = trs.length; i < I; i += 1) {\n\t\t\t\t\tconst tr = trs[i];\n\t\t\t\t\tif (!containsOnlyTh(tr)) break;\n\t\t\t\t\ttrsH.push(tr);\n\t\t\t\t}\n\t\t\t\tif (trsH.length === 0) return null;\n\t\t\n\t\t\t\tconst thead = this._table.createTHead();\n\t\t\t\tfor (let i = 0; i < trsH.length; i += 1) {\n\t\t\t\t\tthead.appendChild(trsH[i]);\n\t\t\t\t}\n\t\t\t\treturn thead;\n\t\t\t}\n\t\t\n\t\t\t_createScrollBarClone() {\n\t\t\t\tconst sbar = document.createElement('div');\n\t\t\t\tNS.addStile(sbar, ST_SCROLL_BAR);\n\t\t\t\tthis._table.parentNode.appendChild(sbar);\n\t\t\t\tconst spacer = document.createElement('div');\n\t\t\t\tsbar.appendChild(spacer);\n\t\t\t\treturn sbar;\n\t\t\t}\n\t\t\n\t\t\t_createEnlargerButton() {\n\t\t\t\tconst ebtn = document.createElement('div');\n\t\t\t\tebtn.dataset['stile'] = ST_ENLARGER_BUTTON;\n\t\t\t\tthis._table.appendChild(ebtn);\n\t\t\t\treturn ebtn;\n\t\t\t}\n\t\t\n\t\t\t_createShade() {\n\t\t\t\tconst shade = document.createElement('div');\n\t\t\t\tshade.dataset['stile'] = ST_TABLE_SHADE;\n\t\t\t\tthis._table.appendChild(shade);\n\t\t\t\treturn shade;\n\t\t\t}\n\t\t\n\t\t\n\t\t\t// ---------------------------------------------------------------------\n\t\t\n\t\t\n\t\t\t_initialize() {\n\t\t\t\tconst bg = getComputedStyle(this._table).backgroundColor;\n\t\t\t\tif (bg && bg !== 'transparent') this._table.dataset['background'] = bg;\n\t\t\n\t\t\t\tthis._initTableScroll();\n\t\t\t\tif (this._ebtn) {\n\t\t\t\t\tthis._ebtn.addEventListener('click', () => {\n\t\t\t\t\t\tif (this._isEnlarged) this._turnOffEnlarged();\n\t\t\t\t\t\telse this._turnOnEnlarged();\n\t\t\t\t\t});\n\t\t\t\t\tif (!this._isEnlargable()) this._ebtn.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tthis._resize();\n\t\t\t\tthis._adjustUnexpectedScrollBar()\n\t\t\t}\n\t\t\n\t\t\t_initTableScroll() {\n\t\t\t\tlet tableScrollChanged = false;\n\t\t\t\tlet sbarScrollChanged  = false;\n\t\t\t\tthis._table.addEventListener('scroll', NS.throttle(() => {\n\t\t\t\t\tif (tableScrollChanged) {\n\t\t\t\t\t\ttableScrollChanged = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._sbar.scrollLeft = this._table.scrollLeft;\n\t\t\t\t\t\tsbarScrollChanged = true;\n\t\t\t\t\t}\n\t\t\t\t\tthis._onTableScroll();\n\t\t\t\t}));\n\t\t\t\tthis._sbar.addEventListener('scroll', NS.throttle(() => {\n\t\t\t\t\tif (sbarScrollChanged) {\n\t\t\t\t\t\tsbarScrollChanged = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._table.scrollLeft = this._sbar.scrollLeft;\n\t\t\t\t\t\ttableScrollChanged = true;\n\t\t\t\t\t}\n\t\t\t\t}));\n\t\t\t}\n\t\t\n\t\t\t_isScrollable() {\n\t\t\t\tconst t = this._table;\n\t\t\t\treturn (t.scrollWidth - t.clientWidth > 2);  // for avoiding needless scrolling\n\t\t\t}\n\t\t\n\t\t\t_isEnlargable() {\n\t\t\t\tconst t = this._table;\n\t\t\t\tconst ww = Math.min(window.outerWidth, window.innerWidth);  // for iOS\n\t\t\t\treturn (t.scrollWidth - t.offsetWidth > 1 && t.offsetWidth < ENLARGER_WINDOW_WIDTH_RATIO * ww);  // for avoiding needless scrolling\n\t\t\t}\n\t\t\n\t\t\t_turnOnEnlarged() {\n\t\t\t\tconst tab = this._table;\n\t\t\t\tif (tab.scrollWidth - tab.offsetWidth <= 1) return;\n\t\t\n\t\t\t\ttab.scrollLeft  = 0;\n\t\t\t\ttab.style.width = 'calc(100vw - ' + scrollBarWidth + 'px)';\n\t\t\t\tNS.addStile(tab, ST_STATE_ENLARGED);\n\t\t\t\tif (this._head) NS.addStile(this._head, ST_STATE_ENLARGED);\n\t\t\t\tthis._isEnlarged = true;\n\t\t\n\t\t\t\t// Do this timing!\n\t\t\t\tlet left = tab.getBoundingClientRect().left + window.pageXOffset;\n\t\t\t\tconst tbody = tab.tBodies[0];\n\t\t\t\tconst width = tbody.clientWidth, pwidth = this._windowWidth - scrollBarWidth;\n\t\t\t\tif (width < pwidth) left -= (pwidth - width) / 2;\n\t\t\t\ttab.style.marginLeft = -left + 'px';\n\t\t\n\t\t\t\ttab.style.background = null;\n\t\t\t\tthis._resize();\n\t\t\t}\n\t\t\n\t\t\t_turnOffEnlarged() {\n\t\t\t\tconst tab = this._table;\n\t\t\t\ttab.style.marginLeft = '';\n\t\t\t\ttab.style.width      = '';\n\t\t\t\ttab.scrollLeft       = 0;\n\t\t\t\tNS.removeStile(tab, ST_STATE_ENLARGED);\n\t\t\t\tif (this._head) NS.removeStile(this._head, ST_STATE_ENLARGED);\n\t\t\t\tthis._isEnlarged = false;\n\t\t\n\t\t\t\tNS.removeStile(this._shade, 'visible');\n\t\t\t\tthis._shade.style.background = null;\n\t\t\t\tthis._resize();\n\t\t\t}\n\t\t\n\t\t\n\t\t\t// ---------------------------------------------------------------------\n\t\t\n\t\t\n\t\t\tonWindowResize() {\n\t\t\t\tthis._adjustUnexpectedScrollBar();\n\t\t\t\tconst ww = Math.min(window.outerWidth, window.innerWidth);  // for iOS\n\t\t\t\tif (this._windowWidth === ww) return;\n\t\t\t\tthis._windowWidth = ww;\n\t\t\n\t\t\t\tif (this._isEnlarged) {\n\t\t\t\t\tthis._turnOffEnlarged();\n\t\t\t\t} else {\n\t\t\t\t\tthis._resize();\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t_adjustUnexpectedScrollBar() {\n\t\t\t\tconst t = this._table;\n\t\t\t\tt.style.overflowX = (t.scrollWidth < t.clientWidth + 2) ? 'hidden' : '';\n\t\t\t}\n\t\t\n\t\t\t_resize() {\n\t\t\t\tif (this._head) this._updateHeaderSize(this._head);\n\t\t\t\tif (this._sbar) this._updateScrollBarSize(this._sbar);\n\t\t\t\tif (this._head || this._sbar) this.onWindowScroll();\n\t\t\t\tthis._onTableScroll();\n\t\t\t}\n\t\t\n\t\t\t_updateHeaderSize(cont) {\n\t\t\t\tcont.style.maxWidth = this._table.getBoundingClientRect().width + 'px';\n\t\t\t\tcont.style.display = 'none';\n\t\t\t\tcont.style.top = getOffset() + 'px';\n\t\t\n\t\t\t\tconst thead = this._table.tHead;\n\t\t\t\tlet w = thead.getBoundingClientRect().width;\n\t\t\t\tconst ptab = cont.firstChild;\n\t\t\t\tptab.style.width = w + 'px';\n\t\t\n\t\t\t\tconst clone = ptab.firstChild;\n\t\t\n\t\t\t\tconst oTrs = thead.rows;\n\t\t\t\tconst cTrs = clone.rows;\n\t\t\t\tfor (let i = 0; i < oTrs.length; i += 1) {\n\t\t\t\t\tcopyWidth(oTrs[i], cTrs[i], 'td');\n\t\t\t\t\tcopyWidth(oTrs[i], cTrs[i], 'th');\n\t\t\t\t}\n\t\t\t\tthis._headerHeight = thead.getBoundingClientRect().height;\n\t\t\t\tfunction copyWidth(o, c, tag) {\n\t\t\t\t\tconst os = o.getElementsByTagName(tag);\n\t\t\t\t\tconst cs = c.getElementsByTagName(tag);\n\t\t\t\t\tfor (let i = 0; i < os.length; i += 1) {\n\t\t\t\t\t\tcs[i].style.width = os[i].getBoundingClientRect().width + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t_updateScrollBarSize(sbar) {\n\t\t\t\tsbar.style.maxWidth = this._table.clientWidth + 'px';\n\t\t\t\tsbar.style.display = 'none';\n\t\t\t\tconst h = parseInt(_getScrollBarWidth());\n\t\t\t\tif (0 < h) sbar.style.height = (h + 2) + 'px';\n\t\t\n\t\t\t\tconst tbody = this._table.tBodies[0];\n\t\t\t\tconst spacer = sbar.firstChild;\n\t\t\t\tspacer.style.width = Math.ceil(tbody.clientWidth) + 'px';\n\t\t\t}\n\t\t\n\t\t\n\t\t\t// ---------------------------------------------------------------------\n\t\t\n\t\t\n\t\t\tonWindowScroll() {\n\t\t\t\tconst tr     = this._table.getBoundingClientRect();\n\t\t\t\tconst tabTop = tr.top, tabBottom = tr.bottom;\n\t\t\t\tconst offset = getOffset();\n\t\t\t\tconst capH   = this._capt ? this._capt.offsetHeight : 0;\n\t\t\t\tconst headH  = this._headerHeight;\n\t\t\t\tconst inView = tabBottom - tabTop - capH < CAPABLE_WINDOW_HEIGHT_RATIO * (window.innerHeight - offset);\n\t\t\n\t\t\t\tlet headVisible = false;\n\t\t\t\tif (inView) {  // do nothing\n\t\t\t\t} else if (offset < tabTop + capH) {  // do nothing\n\t\t\t\t} else if (tabBottom - headH < offset) {  // do nothing\n\t\t\t\t} else if (tabTop + capH < offset) {\n\t\t\t\t\theadVisible = true;\n\t\t\t\t}\n\t\t\t\tlet sbarVisible = false;\n\t\t\t\tif (inView) {  // do nothing\n\t\t\t\t} else if (window.innerHeight < tabTop + capH + headH) {  // do nothing\n\t\t\t\t} else if (tabBottom < window.innerHeight) {  // do nothing\n\t\t\t\t} else if (this._isScrollable()) {\n\t\t\t\t\tsbarVisible = true;\n\t\t\t\t}\n\t\t\t\tif (this._head) this.updateHeaderVisibility(headVisible, tr.left);\n\t\t\t\tif (this._sbar) this.updateScrollBarVisibility(sbarVisible, tr.left);\n\t\t\t}\n\t\t\n\t\t\tupdateHeaderVisibility(visible, tabLeft) {\n\t\t\t\tconst head = this._head;\n\t\t\t\tif (visible) {\n\t\t\t\t\thead.style.top     = getOffset() + 'px';\n\t\t\t\t\thead.style.display = 'block';\n\t\t\t\t\tif (this._ebtn && head) this.switchEnlargerToFloatingHeader();\n\t\t\t\t} else {\n\t\t\t\t\thead.style.display = 'none';\n\t\t\t\t\tif (this._ebtn && head) this.switchEnlargerToTable();\n\t\t\t\t}\n\t\t\t\thead.style.left = tabLeft + 'px';\n\t\t\t\thead.scrollLeft = this._table.scrollLeft;\n\t\t\t}\n\t\t\n\t\t\tswitchEnlargerToTable() {\n\t\t\t\tthis._ebtn.parentNode.removeChild(this._ebtn);\n\t\t\t\tthis._ebtn.style.top = this._capt ? (this._capt.offsetHeight + 'px') : 0;\n\t\t\t\tthis._table.appendChild(this._ebtn);\n\t\t\t}\n\t\t\n\t\t\tswitchEnlargerToFloatingHeader() {\n\t\t\t\tthis._ebtn.parentNode.removeChild(this._ebtn);\n\t\t\t\tthis._ebtn.style.top = 0;\n\t\t\t\tthis._head.appendChild(this._ebtn);\n\t\t\t}\n\t\t\n\t\t\tupdateScrollBarVisibility(visible, tabLeft) {\n\t\t\t\tconst sbar = this._sbar;\n\t\t\t\tif (visible) {\n\t\t\t\t\tsbar.style.display = 'block';\n\t\t\t\t} else {\n\t\t\t\t\tsbar.style.display = 'none';\n\t\t\t\t}\n\t\t\t\tsbar.style.left = tabLeft + 'px';\n\t\t\t\tsbar.scrollLeft = this._table.scrollLeft;\n\t\t\t}\n\t\t\n\t\t\n\t\t\t// ---------------------------------------------------------------------\n\t\t\n\t\t\n\t\t\t_onTableScroll() {\n\t\t\t\tconst tab = this._table, head = this._head, capt = this._capt, ebtn = this._ebtn, shade = this._shade;\n\t\t\t\tconst sL = Math.max(0, Math.min(tab.scrollLeft, tab.scrollWidth - tab.offsetWidth));  // for iOS\n\t\t\t\tif (head) head.scrollLeft = sL;\n\t\t\t\tif (capt) {\n\t\t\t\t\tif (this._isScrollable()) {\n\t\t\t\t\t\tif (this._stCapt) clearTimeout(this._stCapt);\n\t\t\t\t\t\tthis._stCapt = setTimeout(() => { capt.style.transform = `translateX(${sL}px)`; }, 200);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcapt.style.transform = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ebtn) {\n\t\t\t\t\tNS.removeStile(ebtn, 'visible');\n\t\t\t\t\tif (this._stEbtn) clearTimeout(this._stEbtn);\n\t\t\t\t\tthis._stEbtn = setTimeout(() => { NS.addStile(ebtn, 'visible'); }, 100);\n\t\t\t\t\tthis._updateEnlager();\n\t\t\t\t}\n\t\t\n\t\t\t\tif (this._isEnlarged) {\n\t\t\t\t\tNS.removeStile(shade, 'visible');\n\t\t\t\t\tif (this._isScrollable() && this._isEnlarged) {\n\t\t\t\t\t\tif (this._stShade) clearTimeout(this._stShade);\n\t\t\t\t\t\tthis._stShade = setTimeout(() => {\n\t\t\t\t\t\t\tshade.style.transform = `translateX(${sL}px)`;\n\t\t\t\t\t\t\tNS.addStile(shade, 'visible');\n\t\t\t\t\t\t}, 100);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._updateShade();\n\t\t\t}\n\t\t\n\t\t\t_updateEnlager() {\n\t\t\t\tconst tab = this._table, capt = this._capt, ebtn = this._ebtn;\n\t\t\t\tconst sL = tab.scrollLeft;\n\t\t\n\t\t\t\tconst tbody = this._table.tBodies[0];\n\t\t\t\tconst scrW = tbody.clientWidth, cltW = tab.clientWidth;\n\t\t\t\tif (this._isEnlargable() || this._isEnlarged) {\n\t\t\t\t\tlet etbRight = -Math.min(scrW - cltW, sL);  // for Mobile Safari\n\t\t\t\t\tif (!this._isEnlargable() && this._isEnlarged) {\n\t\t\t\t\t\tconst diff = ebtn.parentElement.clientWidth - scrW;\n\t\t\t\t\t\tif (0 < diff) etbRight = diff;\n\t\t\t\t\t}\n\t\t\t\t\tif (ebtn.parentNode === tab) ebtn.style.top = capt ? (capt.offsetHeight + 'px') : 0;\n\t\t\t\t\tebtn.style.right = etbRight + 'px';\n\t\t\t\t\tebtn.style.display = 'block';\n\t\t\t\t} else {\n\t\t\t\t\tebtn.style.display = 'none';\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t_updateShade() {\n\t\t\t\tconst tab = this._table, shade = this._shade;\n\t\t\t\tif (this._isScrollable()) {\n\t\t\t\t\tconst s = this._calcShadeStyle();\n\t\t\t\t\tif (this._isEnlarged) {\n\t\t\t\t\t\tshade.style.background = s;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttab.style.background = s;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttab.style.background = '';  // This must be '' for IE11\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\t_calcShadeStyle() {\n\t\t\t\tconst tab = this._table;\n\t\t\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\n\t\t\t\tlet rl = 0.25, rr = 0.25;\n\t\t\t\tif (r < 0.1) rl *= r / 0.1;\n\t\t\t\tif (0.9 < r) rr *= (1 - r) / 0.1;\n\t\t\t\tconst ch = this._capt ? (this._capt.offsetHeight + 'px') : '0';\n\t\t\t\tconst sl = `linear-gradient(to left, rgba(0,0,0,0), rgba(0,0,0,${rl}) 1.25rem) 0 ${ch} / 1.25rem 100% no-repeat scroll`;\n\t\t\t\tconst sr = `linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,${rr}) 1.25rem) right ${ch} / 1.25rem 100% no-repeat scroll`;\n\t\t\n\t\t\t\tconst bg = this._table.dataset['background'];\n\t\t\t\tconst sb = (this._isEnlarged || !bg || bg === 'transparent') ? '' : `, linear-gradient(to bottom, ${bg}, ${bg}) 0px 0px / 100% 100% no-repeat`;\n\t\t\t\treturn sl + ',' + sr + sb;\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\t\n\t\t// Utilities ---------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction _getScrollBarWidth() {\n\t\t\tconst dummy = document.createElement('div');\n\t\t\tdummy.style.bottom = '100%';\n\t\t\tdummy.style.height = '1px';\n\t\t\tdummy.style.position = 'absolute';\n\t\t\tdummy.style.width = 'calc(100vw - 100%)';\n\t\t\tdocument.body.appendChild(dummy);\n\t\t\tlet width = 0 | window.getComputedStyle(dummy, '').getPropertyValue('width');\n\t\t\n\t\t\tif (width === 0) {  // Window does not have any scroll bar\n\t\t\t\tdummy.style.overflowY = 'scroll';\n\t\t\t\tdummy.style.width = '';\n\t\t\t\tconst c = document.createElement('div');\n\t\t\t\tc.style.minHeight = '100px';\n\t\t\t\tdummy.appendChild(c);\n\t\t\t\tconst cw = 0 | window.getComputedStyle(c, '').getPropertyValue('width');\n\t\t\t\twidth = dummy.offsetWidth - cw;\n\t\t\t}\n\t\t\tdocument.body.removeChild(dummy);\n\t\t\treturn width;\n\t\t}\n\t\t\n\t\tNS.tableFixedHeader = initialize;\n\t})();\n\n})(window.NACSS);\n","/**\n *\n * Neat Width\n *\n * @author Takuto Yanagida\n * @version 2021-01-04\n *\n */\n\n\nfunction initialize(tabs, opts = {}) {\n\tif (tabs.length === 0) return;\n\tconst lt = tabs[tabs.length - 1];\n\tconst cm = Object.assign(opts, getCommonMetrics(lt), {\n\t\tnnwMinWidthRate : 0.1,\n\t\tcellMinWidth    : 100,\n\t\tcellMinAspect   : 2 / 3,  // width / height\n\t\tcellMinLength   : 8,\n\t\tmaxRowSize      : 200,\n\t\tmaxBorderWidth  : 2,\n\t});\n\tcm.padH += cm.maxBorderWidth * 2;\n\tcm.padV += cm.maxBorderWidth * 2;\n\tcm.dcTd = makeDummyCell(lt, 'td');\n\tcm.dcTh = makeDummyCell(lt, 'th');\n\tfor (const t of tabs) {\n\t\tif (!apply(t, cm) && cm.nnwMinWidthRate) {\n\t\t\tconst pw = t.parentElement.clientWidth;\n\t\t\tconst w  = t.clientWidth;\n\t\t\tif (pw - w < w * cm.nnwMinWidthRate) t.style.width = '100%';\n\t\t}\n\t}\n\tlt.removeChild(cm.dcTd);\n\tlt.removeChild(cm.dcTh);\n}\n\nfunction makeDummyCell(t, tagName) {\n\tconst d = document.createElement(tagName);\n\td.style.display    = 'inline-block';\n\td.style.position   = 'fixed';\n\td.style.visibility = 'hidden';\n\td.style.whiteSpace = 'nowrap';\n\treturn t.appendChild(d);\n}\n\nfunction getCommonMetrics(tab) {\n\tconst td = tab.getElementsByTagName('td')[0];\n\tconst s = getComputedStyle(td);\n\tconst padH  = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);\n\tconst padV  = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);\n\tconst [charW, lineH] = getTextSize(td);\n\treturn { padH, padV, charW, lineH };\n}\n\nfunction getTextSize(elm) {\n\tconst temp = document.createElement(elm.nodeName);\n\ttemp.setAttribute('style', `position:fixed;margin:0;padding:0;font-family:${elm.style.fontFamily || 'inherit'};font-size:${elm.style.fontSize || 'inherit'};`);\n\ttemp.innerHTML = '\\u3000';  // Full width space\n\telm.parentNode.appendChild(temp);\n\tconst w = temp.clientWidth;\n\tconst h = temp.clientHeight;\n\ttemp.parentNode.removeChild(temp);\n\treturn [w, h];\n}\n\nfunction apply(tab, cMet) {\n\tif (tab.rows.length === 0) return false;\n\tif (cMet.maxRowSize < tab.rows.length) return false;\n\tif (!isResizeNeeded(tab, cMet)) return false;\n\n\tif (tab.hasAttribute('width')) tab.removeAttribute('width');\n\ttab.style.width    = '';\n\ttab.style.maxWidth = '';\n\n\tconst grid  = makeCellGrid(tab);\n\tconst met   = Object.assign(getMetrics(tab, grid), cMet);\n\tconst newWs = calcNewWidths(grid, met);\n\tsetCellWidth(grid, newWs);\n\treturn true;\n}\n\nfunction isResizeNeeded(tab, cMet) {\n\tconst { cellMinWidth, cellMinAspect } = cMet;\n\tfor (const tr of tab.rows) {\n\t\tif (!tr.hasChildNodes()) continue;\n\t\tfor (const n of tr.childNodes) {\n\t\t\tconst tn = n.tagName;\n\t\t\tif (tn !== 'TD' && tn !== 'TH') continue;\n\t\t\tif (1 < parseInt(n.getAttribute('colSpan'), 10)) continue;\n\t\t\tif (1 < parseInt(n.getAttribute('rowSpan'), 10)) continue;\n\t\t\tconst cw = n.clientWidth;\n\t\t\tconst ch = n.clientHeight;\n\t\t\tif (cw < cellMinWidth || cw / ch < cellMinAspect) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction makeCellGrid(t) {\n\tconst css = collectCells(t);\n\tlet maxWidth = 0;\n\tfor (const cs of css) maxWidth = Math.max(maxWidth, cs.length);\n\tconst g = [];\n\tfor (const cs of css) g.push(new Array(maxWidth));\n\n\tfor (let y = 0; y < g.length; y += 1) {\n\t\tconst gr = g[y];\n\t\tconst tds = css[y];\n\t\tlet i = 0;\n\n\t\tfor (let x = 0; x < maxWidth; x += 1) {\n\t\t\tif (typeof gr[x] === 'number' || gr[x] === null) continue;\n\n\t\t\tconst td = tds[i]\n\t\t\tconst col = parseInt(td.getAttribute('colSpan') ?? 1, 10);\n\t\t\tconst row = parseInt(td.getAttribute('rowSpan') ?? 1, 10);\n\t\t\tgr[x] = td;\n\n\t\t\tif (1 < col) {\n\t\t\t\tfor (let p = 1; p < col; p += 1) gr[x + p] = p;\n\t\t\t}\n\t\t\tif (1 < row) {\n\t\t\t\tfor (let q = 1; q < row; q += 1) {\n\t\t\t\t\tconst nr = g[y + q];\n\t\t\t\t\tfor (let p = 0; p < col; p += 1) nr[x + p] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += 1;\n\t\t\tif (tds.length <= i) break;\n\t\t}\n\t}\n\treturn g;\n}\n\nfunction collectCells(t, css = []) {\n\tfor (const tr of t.rows) {\n\t\tconst cs = [];\n\t\tif (tr.hasChildNodes()) {\n\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\tconst tn = n.tagName;\n\t\t\t\tif (tn === 'TD' || tn === 'TH') cs.push(n);\n\t\t\t}\n\t\t}\n\t\tcss.push(cs);\n\t}\n\treturn css;\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction getMetrics(tab, grid) {\n\tconst origTabW = tab.clientWidth;\n\tconst origCellWs = [];\n\tfor (let x = 0; x < grid[0].length; x += 1) {\n\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\tconst g = grid[y][x];\n\t\t\tif (g instanceof HTMLTableCellElement && !g.getAttribute('colSpan')) {\n\t\t\t\torigCellWs.push(g.clientWidth);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn { origTabW, origCellWs };\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction calcNewWidths(grid, met) {\n\tfor (const gr of grid) {\n\t\tfor (const gc of gr) {\n\t\t\tif (typeof gc !== 'number' && gc !== null) gc.style.whiteSpace = 'nowrap';\n\t\t}\n\t}\n\tconst gw = grid[0].length;\n\tconst newWs = new Array(gw).fill(false);\n\tconst wrapped = new Array(gw).fill(false);\n\n\tfor (let y = 0; y < grid.length; y += 1) {\n\t\tconst gridRow = grid[y];\n\n\t\tfor (let x = 0; x < gw; x += 1) {\n\t\t\tconst td = gridRow[x];\n\t\t\tif (td === undefined || td === null || typeof td === 'number') continue;\n\t\t\tif (x < gw - 1 && typeof gridRow[x + 1] === 'number') continue;\n\t\t\tif (1 < parseInt(td.getAttribute('colSpan'), 10)) continue;\n\t\t\tif (1 < parseInt(td.getAttribute('rowSpan'), 10)) continue;\n\n\t\t\tconst [minW, wp] = calcMinWidth(td, met);\n\t\t\tif (minW) newWs[x] = Math.max(newWs[x], minW);\n\t\t\tif (wp) wrapped[x] = wp;\n\t\t}\n\t}\n\twidenTabWidth(newWs, wrapped, met);\n\treturn newWs;\n}\n\nfunction calcMinWidth(td, met) {\n\tconst { padH, padV, charW, lineH, cellMinWidth, dcTd, dcTh, cellMinAspect, cellMinLength } = met;\n\tif (calcMaxLineLength(td) < cellMinLength) return [0, false];\n\n\ttd.innerHTML = td.innerHTML.trim();\n\tconst dc = td.tagName === 'TD' ? dcTd : dcTh;\n\tdc.innerHTML = td.innerHTML;\n\tconst aw = dc.clientWidth - padH;\n\tconst ls = Math.round((dc.clientHeight - padV) / lineH);\n\tlet minW = 0, wrapped = false;\n\tfor (let i = 1; ; i += 1) {\n\t\tconst tempW = 0 | (aw / i + charW * i + padH);\n\t\tconst tempH = ls * (i * lineH) + padV;\n\t\tif (tempW < cellMinWidth || tempW / tempH < cellMinAspect || (minW && minW < tempW)) break;\n\t\tif (1 < i) wrapped = true;\n\t\tminW = tempW;\n\t}\n\treturn [minW, wrapped];\n}\n\nfunction calcMaxLineLength(td) {\n\tconst ih = td.innerHTML.trim();\n\tlet ls = ih.split(/<\\s*br\\s*\\/?>/ui);\n\tif (ls.length === 0) ls = [ih];\n\tconst ts = ls.map(e => e.replace(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/g, '').length);\n\treturn Math.max(...ts);\n}\n\nfunction widenTabWidth(newWs, wrapped, met) {\n\tconst { origTabW, origCellWs } = met;\n\tlet wNew = 0, wFix = 0;\n\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\tif (wrapped[i]) {\n\t\t\twNew += newWs[i];\n\t\t} else if (newWs[i]) {\n\t\t\twFix += newWs[i];\n\t\t} else {\n\t\t\twFix += origCellWs[i];\n\t\t}\n\t}\n\tif (origTabW < wNew + wFix) return;\n\tlet rem = origTabW - wFix;\n\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\tif (!wrapped[i]) continue;\n\t\tconst nw = newWs[i];\n\t\tconst w = Math.min(nw / wNew * rem, origCellWs[i]);\n\t\trem  -= (w - nw);\n\t\twNew -= (w - nw);\n\t\tnewWs[i] = 0 | w;\n\t}\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction setCellWidth(grid, ws) {\n\tfor (const gr of grid) {\n\t\tfor (let x = 0; x < gr.length; x += 1) {\n\t\t\tconst gc = gr[x], w = ws[x];\n\t\t\tif (w === false || !(gc instanceof HTMLTableCellElement)) continue;\n\t\t\tgc.style.whiteSpace = null;\n\t\t\tgc.style.minWidth   = w + 'px';\n\t\t\tgc.style.width      = null;\n\t\t}\n\t}\n}\n","/**\r\n *\r\n * Fixed Header (JS)\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2021-01-04\r\n *\r\n */\r\n\r\n\r\nconst SEL_TARGET = '.stile';\r\n\r\nconst ST_HEADER_CONTAINER = 'fixed-table-header-container';\r\nconst ST_HEADER_TABLE     = 'fixed-table-header-table';\r\nconst ST_SCROLL_BAR       = 'fixed-table-scroll-bar';\r\nconst ST_ENLARGER_BUTTON  = 'enlarger-button';\r\nconst ST_TABLE_SHADE      = 'table-shade';\r\nconst ST_STATE_ENLARGED   = 'table-enlarged';\r\nconst ST_OPT_NO_ENLARGER  = 'no-enlarger';\r\n\r\nconst CAPABLE_WINDOW_HEIGHT_RATIO = 0.9;\r\nconst ENLARGER_WINDOW_WIDTH_RATIO = 0.9;\r\n\r\nlet getOffset;\r\nlet scrollBarWidth;\r\n\r\n// NS.addInit(4, () => {\r\n// \tgetOffset = NS.makeOffsetFunction(false, true);  // Initialize here\r\n\r\n// \tconst tabs = document.querySelectorAll(SEL_TARGET + ' table:not([class])');\r\n// \tsetTimeout(() => { initialize(tabs); }, 0);  // Delay for IE11\r\n// });\r\n\r\n\r\n// -------------------------------------------------------------------------\r\n\r\n\r\nfunction initialize(tabs) {\r\n\tscrollBarWidth = parseInt(_getScrollBarWidth());\r\n\tconst conts = [];\r\n\tfor (let i = 0; i < tabs.length; i += 1) conts.push(new FixedHeaderTable(tabs[i]));\r\n\tNS.onScroll(() => { for (let i = 0; i < conts.length; i += 1) conts[i].onWindowScroll(); });\r\n\tNS.onResize(() => { for (let i = 0; i < conts.length; i += 1) conts[i].onWindowResize(); });\r\n}\r\n\r\nclass FixedHeaderTable {\r\n\r\n\tconstructor (tab) {\r\n\t\tif (tab.style.height) tab.style.height = '';\r\n\t\tthis._table        = tab;\r\n\t\tthis._headerHeight = 0;\r\n\t\tthis._isEnlarged   = false;\r\n\t\tthis._windowWidth  = Math.min(window.outerWidth, window.innerWidth);  // for iOS\r\n\t\tthis._create();\r\n\t\tsetTimeout(() => { this._initialize(); }, 10);\r\n\t}\r\n\r\n\t_create() {\r\n\t\tthis._head = this._createHeaderClone();\r\n\t\tthis._sbar = this._createScrollBarClone();\r\n\t\tthis._ebtn = NS.containStile(this._table, ST_OPT_NO_ENLARGER) ? null : this._createEnlargerButton();\r\n\t\tthis._shade = this._createShade();\r\n\r\n\t\tconst caps = this._table.getElementsByTagName('caption');\r\n\t\tthis._capt = caps.length ? caps[0] : null;\r\n\t}\r\n\r\n\t_createHeaderClone() {\r\n\t\tlet thead = this._table.tHead;\r\n\t\tif (!thead) {\r\n\t\t\tthead = this._createPseudoHeader();\r\n\t\t\tif (!thead) return null;\r\n\t\t\tthis._table.tHead = thead;\r\n\t\t}\r\n\t\tconst cont = document.createElement('div');\r\n\t\tNS.addStile(cont, ST_HEADER_CONTAINER);\r\n\t\tthis._table.parentNode.appendChild(cont);\r\n\r\n\t\tconst ptab = document.createElement('div');\r\n\t\tNS.addStile(ptab, ST_HEADER_TABLE);\r\n\t\tcont.appendChild(ptab);\r\n\r\n\t\tconst clone = thead.cloneNode(true);\r\n\t\tptab.appendChild(clone);\r\n\r\n\t\tif (NS.containStile(this._table, ST_STATE_ENLARGED)) NS.addStile(cont, ST_STATE_ENLARGED);\r\n\t\treturn cont;\r\n\t}\r\n\r\n\t_createPseudoHeader() {\r\n\t\tconst tbody = this._table.tBodies[0];\r\n\t\tconst trs = tbody.rows;\r\n\t\tif (trs.length === 0) return null;\r\n\r\n\t\tfunction containsOnlyTh(tr) {\r\n\t\t\tconst tds = tr.getElementsByTagName('td');\r\n\t\t\tconst ths = tr.getElementsByTagName('th');\r\n\t\t\tif (tds.length === 0 && ths.length > 0) return true;\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tconst trsH = [];\r\n\t\tfor (let i = 0, I = trs.length; i < I; i += 1) {\r\n\t\t\tconst tr = trs[i];\r\n\t\t\tif (!containsOnlyTh(tr)) break;\r\n\t\t\ttrsH.push(tr);\r\n\t\t}\r\n\t\tif (trsH.length === 0) return null;\r\n\r\n\t\tconst thead = this._table.createTHead();\r\n\t\tfor (let i = 0; i < trsH.length; i += 1) {\r\n\t\t\tthead.appendChild(trsH[i]);\r\n\t\t}\r\n\t\treturn thead;\r\n\t}\r\n\r\n\t_createScrollBarClone() {\r\n\t\tconst sbar = document.createElement('div');\r\n\t\tNS.addStile(sbar, ST_SCROLL_BAR);\r\n\t\tthis._table.parentNode.appendChild(sbar);\r\n\t\tconst spacer = document.createElement('div');\r\n\t\tsbar.appendChild(spacer);\r\n\t\treturn sbar;\r\n\t}\r\n\r\n\t_createEnlargerButton() {\r\n\t\tconst ebtn = document.createElement('div');\r\n\t\tebtn.dataset['stile'] = ST_ENLARGER_BUTTON;\r\n\t\tthis._table.appendChild(ebtn);\r\n\t\treturn ebtn;\r\n\t}\r\n\r\n\t_createShade() {\r\n\t\tconst shade = document.createElement('div');\r\n\t\tshade.dataset['stile'] = ST_TABLE_SHADE;\r\n\t\tthis._table.appendChild(shade);\r\n\t\treturn shade;\r\n\t}\r\n\r\n\r\n\t// ---------------------------------------------------------------------\r\n\r\n\r\n\t_initialize() {\r\n\t\tconst bg = getComputedStyle(this._table).backgroundColor;\r\n\t\tif (bg && bg !== 'transparent') this._table.dataset['background'] = bg;\r\n\r\n\t\tthis._initTableScroll();\r\n\t\tif (this._ebtn) {\r\n\t\t\tthis._ebtn.addEventListener('click', () => {\r\n\t\t\t\tif (this._isEnlarged) this._turnOffEnlarged();\r\n\t\t\t\telse this._turnOnEnlarged();\r\n\t\t\t});\r\n\t\t\tif (!this._isEnlargable()) this._ebtn.style.display = 'none';\r\n\t\t}\r\n\t\tthis._resize();\r\n\t\tthis._adjustUnexpectedScrollBar()\r\n\t}\r\n\r\n\t_initTableScroll() {\r\n\t\tlet tableScrollChanged = false;\r\n\t\tlet sbarScrollChanged  = false;\r\n\t\tthis._table.addEventListener('scroll', NS.throttle(() => {\r\n\t\t\tif (tableScrollChanged) {\r\n\t\t\t\ttableScrollChanged = false;\r\n\t\t\t} else {\r\n\t\t\t\tthis._sbar.scrollLeft = this._table.scrollLeft;\r\n\t\t\t\tsbarScrollChanged = true;\r\n\t\t\t}\r\n\t\t\tthis._onTableScroll();\r\n\t\t}));\r\n\t\tthis._sbar.addEventListener('scroll', NS.throttle(() => {\r\n\t\t\tif (sbarScrollChanged) {\r\n\t\t\t\tsbarScrollChanged = false;\r\n\t\t\t} else {\r\n\t\t\t\tthis._table.scrollLeft = this._sbar.scrollLeft;\r\n\t\t\t\ttableScrollChanged = true;\r\n\t\t\t}\r\n\t\t}));\r\n\t}\r\n\r\n\t_isScrollable() {\r\n\t\tconst t = this._table;\r\n\t\treturn (t.scrollWidth - t.clientWidth > 2);  // for avoiding needless scrolling\r\n\t}\r\n\r\n\t_isEnlargable() {\r\n\t\tconst t = this._table;\r\n\t\tconst ww = Math.min(window.outerWidth, window.innerWidth);  // for iOS\r\n\t\treturn (t.scrollWidth - t.offsetWidth > 1 && t.offsetWidth < ENLARGER_WINDOW_WIDTH_RATIO * ww);  // for avoiding needless scrolling\r\n\t}\r\n\r\n\t_turnOnEnlarged() {\r\n\t\tconst tab = this._table;\r\n\t\tif (tab.scrollWidth - tab.offsetWidth <= 1) return;\r\n\r\n\t\ttab.scrollLeft  = 0;\r\n\t\ttab.style.width = 'calc(100vw - ' + scrollBarWidth + 'px)';\r\n\t\tNS.addStile(tab, ST_STATE_ENLARGED);\r\n\t\tif (this._head) NS.addStile(this._head, ST_STATE_ENLARGED);\r\n\t\tthis._isEnlarged = true;\r\n\r\n\t\t// Do this timing!\r\n\t\tlet left = tab.getBoundingClientRect().left + window.pageXOffset;\r\n\t\tconst tbody = tab.tBodies[0];\r\n\t\tconst width = tbody.clientWidth, pwidth = this._windowWidth - scrollBarWidth;\r\n\t\tif (width < pwidth) left -= (pwidth - width) / 2;\r\n\t\ttab.style.marginLeft = -left + 'px';\r\n\r\n\t\ttab.style.background = null;\r\n\t\tthis._resize();\r\n\t}\r\n\r\n\t_turnOffEnlarged() {\r\n\t\tconst tab = this._table;\r\n\t\ttab.style.marginLeft = '';\r\n\t\ttab.style.width      = '';\r\n\t\ttab.scrollLeft       = 0;\r\n\t\tNS.removeStile(tab, ST_STATE_ENLARGED);\r\n\t\tif (this._head) NS.removeStile(this._head, ST_STATE_ENLARGED);\r\n\t\tthis._isEnlarged = false;\r\n\r\n\t\tNS.removeStile(this._shade, 'visible');\r\n\t\tthis._shade.style.background = null;\r\n\t\tthis._resize();\r\n\t}\r\n\r\n\r\n\t// ---------------------------------------------------------------------\r\n\r\n\r\n\tonWindowResize() {\r\n\t\tthis._adjustUnexpectedScrollBar();\r\n\t\tconst ww = Math.min(window.outerWidth, window.innerWidth);  // for iOS\r\n\t\tif (this._windowWidth === ww) return;\r\n\t\tthis._windowWidth = ww;\r\n\r\n\t\tif (this._isEnlarged) {\r\n\t\t\tthis._turnOffEnlarged();\r\n\t\t} else {\r\n\t\t\tthis._resize();\r\n\t\t}\r\n\t}\r\n\r\n\t_adjustUnexpectedScrollBar() {\r\n\t\tconst t = this._table;\r\n\t\tt.style.overflowX = (t.scrollWidth < t.clientWidth + 2) ? 'hidden' : '';\r\n\t}\r\n\r\n\t_resize() {\r\n\t\tif (this._head) this._updateHeaderSize(this._head);\r\n\t\tif (this._sbar) this._updateScrollBarSize(this._sbar);\r\n\t\tif (this._head || this._sbar) this.onWindowScroll();\r\n\t\tthis._onTableScroll();\r\n\t}\r\n\r\n\t_updateHeaderSize(cont) {\r\n\t\tcont.style.maxWidth = this._table.getBoundingClientRect().width + 'px';\r\n\t\tcont.style.display = 'none';\r\n\t\tcont.style.top = getOffset() + 'px';\r\n\r\n\t\tconst thead = this._table.tHead;\r\n\t\tlet w = thead.getBoundingClientRect().width;\r\n\t\tconst ptab = cont.firstChild;\r\n\t\tptab.style.width = w + 'px';\r\n\r\n\t\tconst clone = ptab.firstChild;\r\n\r\n\t\tconst oTrs = thead.rows;\r\n\t\tconst cTrs = clone.rows;\r\n\t\tfor (let i = 0; i < oTrs.length; i += 1) {\r\n\t\t\tcopyWidth(oTrs[i], cTrs[i], 'td');\r\n\t\t\tcopyWidth(oTrs[i], cTrs[i], 'th');\r\n\t\t}\r\n\t\tthis._headerHeight = thead.getBoundingClientRect().height;\r\n\t\tfunction copyWidth(o, c, tag) {\r\n\t\t\tconst os = o.getElementsByTagName(tag);\r\n\t\t\tconst cs = c.getElementsByTagName(tag);\r\n\t\t\tfor (let i = 0; i < os.length; i += 1) {\r\n\t\t\t\tcs[i].style.width = os[i].getBoundingClientRect().width + 'px';\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t_updateScrollBarSize(sbar) {\r\n\t\tsbar.style.maxWidth = this._table.clientWidth + 'px';\r\n\t\tsbar.style.display = 'none';\r\n\t\tconst h = parseInt(_getScrollBarWidth());\r\n\t\tif (0 < h) sbar.style.height = (h + 2) + 'px';\r\n\r\n\t\tconst tbody = this._table.tBodies[0];\r\n\t\tconst spacer = sbar.firstChild;\r\n\t\tspacer.style.width = Math.ceil(tbody.clientWidth) + 'px';\r\n\t}\r\n\r\n\r\n\t// ---------------------------------------------------------------------\r\n\r\n\r\n\tonWindowScroll() {\r\n\t\tconst tr     = this._table.getBoundingClientRect();\r\n\t\tconst tabTop = tr.top, tabBottom = tr.bottom;\r\n\t\tconst offset = getOffset();\r\n\t\tconst capH   = this._capt ? this._capt.offsetHeight : 0;\r\n\t\tconst headH  = this._headerHeight;\r\n\t\tconst inView = tabBottom - tabTop - capH < CAPABLE_WINDOW_HEIGHT_RATIO * (window.innerHeight - offset);\r\n\r\n\t\tlet headVisible = false;\r\n\t\tif (inView) {  // do nothing\r\n\t\t} else if (offset < tabTop + capH) {  // do nothing\r\n\t\t} else if (tabBottom - headH < offset) {  // do nothing\r\n\t\t} else if (tabTop + capH < offset) {\r\n\t\t\theadVisible = true;\r\n\t\t}\r\n\t\tlet sbarVisible = false;\r\n\t\tif (inView) {  // do nothing\r\n\t\t} else if (window.innerHeight < tabTop + capH + headH) {  // do nothing\r\n\t\t} else if (tabBottom < window.innerHeight) {  // do nothing\r\n\t\t} else if (this._isScrollable()) {\r\n\t\t\tsbarVisible = true;\r\n\t\t}\r\n\t\tif (this._head) this.updateHeaderVisibility(headVisible, tr.left);\r\n\t\tif (this._sbar) this.updateScrollBarVisibility(sbarVisible, tr.left);\r\n\t}\r\n\r\n\tupdateHeaderVisibility(visible, tabLeft) {\r\n\t\tconst head = this._head;\r\n\t\tif (visible) {\r\n\t\t\thead.style.top     = getOffset() + 'px';\r\n\t\t\thead.style.display = 'block';\r\n\t\t\tif (this._ebtn && head) this.switchEnlargerToFloatingHeader();\r\n\t\t} else {\r\n\t\t\thead.style.display = 'none';\r\n\t\t\tif (this._ebtn && head) this.switchEnlargerToTable();\r\n\t\t}\r\n\t\thead.style.left = tabLeft + 'px';\r\n\t\thead.scrollLeft = this._table.scrollLeft;\r\n\t}\r\n\r\n\tswitchEnlargerToTable() {\r\n\t\tthis._ebtn.parentNode.removeChild(this._ebtn);\r\n\t\tthis._ebtn.style.top = this._capt ? (this._capt.offsetHeight + 'px') : 0;\r\n\t\tthis._table.appendChild(this._ebtn);\r\n\t}\r\n\r\n\tswitchEnlargerToFloatingHeader() {\r\n\t\tthis._ebtn.parentNode.removeChild(this._ebtn);\r\n\t\tthis._ebtn.style.top = 0;\r\n\t\tthis._head.appendChild(this._ebtn);\r\n\t}\r\n\r\n\tupdateScrollBarVisibility(visible, tabLeft) {\r\n\t\tconst sbar = this._sbar;\r\n\t\tif (visible) {\r\n\t\t\tsbar.style.display = 'block';\r\n\t\t} else {\r\n\t\t\tsbar.style.display = 'none';\r\n\t\t}\r\n\t\tsbar.style.left = tabLeft + 'px';\r\n\t\tsbar.scrollLeft = this._table.scrollLeft;\r\n\t}\r\n\r\n\r\n\t// ---------------------------------------------------------------------\r\n\r\n\r\n\t_onTableScroll() {\r\n\t\tconst tab = this._table, head = this._head, capt = this._capt, ebtn = this._ebtn, shade = this._shade;\r\n\t\tconst sL = Math.max(0, Math.min(tab.scrollLeft, tab.scrollWidth - tab.offsetWidth));  // for iOS\r\n\t\tif (head) head.scrollLeft = sL;\r\n\t\tif (capt) {\r\n\t\t\tif (this._isScrollable()) {\r\n\t\t\t\tif (this._stCapt) clearTimeout(this._stCapt);\r\n\t\t\t\tthis._stCapt = setTimeout(() => { capt.style.transform = `translateX(${sL}px)`; }, 200);\r\n\t\t\t} else {\r\n\t\t\t\tcapt.style.transform = null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ebtn) {\r\n\t\t\tNS.removeStile(ebtn, 'visible');\r\n\t\t\tif (this._stEbtn) clearTimeout(this._stEbtn);\r\n\t\t\tthis._stEbtn = setTimeout(() => { NS.addStile(ebtn, 'visible'); }, 100);\r\n\t\t\tthis._updateEnlager();\r\n\t\t}\r\n\r\n\t\tif (this._isEnlarged) {\r\n\t\t\tNS.removeStile(shade, 'visible');\r\n\t\t\tif (this._isScrollable() && this._isEnlarged) {\r\n\t\t\t\tif (this._stShade) clearTimeout(this._stShade);\r\n\t\t\t\tthis._stShade = setTimeout(() => {\r\n\t\t\t\t\tshade.style.transform = `translateX(${sL}px)`;\r\n\t\t\t\t\tNS.addStile(shade, 'visible');\r\n\t\t\t\t}, 100);\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis._updateShade();\r\n\t}\r\n\r\n\t_updateEnlager() {\r\n\t\tconst tab = this._table, capt = this._capt, ebtn = this._ebtn;\r\n\t\tconst sL = tab.scrollLeft;\r\n\r\n\t\tconst tbody = this._table.tBodies[0];\r\n\t\tconst scrW = tbody.clientWidth, cltW = tab.clientWidth;\r\n\t\tif (this._isEnlargable() || this._isEnlarged) {\r\n\t\t\tlet etbRight = -Math.min(scrW - cltW, sL);  // for Mobile Safari\r\n\t\t\tif (!this._isEnlargable() && this._isEnlarged) {\r\n\t\t\t\tconst diff = ebtn.parentElement.clientWidth - scrW;\r\n\t\t\t\tif (0 < diff) etbRight = diff;\r\n\t\t\t}\r\n\t\t\tif (ebtn.parentNode === tab) ebtn.style.top = capt ? (capt.offsetHeight + 'px') : 0;\r\n\t\t\tebtn.style.right = etbRight + 'px';\r\n\t\t\tebtn.style.display = 'block';\r\n\t\t} else {\r\n\t\t\tebtn.style.display = 'none';\r\n\t\t}\r\n\t}\r\n\r\n\t_updateShade() {\r\n\t\tconst tab = this._table, shade = this._shade;\r\n\t\tif (this._isScrollable()) {\r\n\t\t\tconst s = this._calcShadeStyle();\r\n\t\t\tif (this._isEnlarged) {\r\n\t\t\t\tshade.style.background = s;\r\n\t\t\t} else {\r\n\t\t\t\ttab.style.background = s;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\ttab.style.background = '';  // This must be '' for IE11\r\n\t\t}\r\n\t}\r\n\r\n\t_calcShadeStyle() {\r\n\t\tconst tab = this._table;\r\n\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\r\n\t\tlet rl = 0.25, rr = 0.25;\r\n\t\tif (r < 0.1) rl *= r / 0.1;\r\n\t\tif (0.9 < r) rr *= (1 - r) / 0.1;\r\n\t\tconst ch = this._capt ? (this._capt.offsetHeight + 'px') : '0';\r\n\t\tconst sl = `linear-gradient(to left, rgba(0,0,0,0), rgba(0,0,0,${rl}) 1.25rem) 0 ${ch} / 1.25rem 100% no-repeat scroll`;\r\n\t\tconst sr = `linear-gradient(to right, rgba(0,0,0,0), rgba(0,0,0,${rr}) 1.25rem) right ${ch} / 1.25rem 100% no-repeat scroll`;\r\n\r\n\t\tconst bg = this._table.dataset['background'];\r\n\t\tconst sb = (this._isEnlarged || !bg || bg === 'transparent') ? '' : `, linear-gradient(to bottom, ${bg}, ${bg}) 0px 0px / 100% 100% no-repeat`;\r\n\t\treturn sl + ',' + sr + sb;\r\n\t}\r\n\r\n}\r\n\r\n\r\n// Utilities ---------------------------------------------------------------\r\n\r\n\r\nfunction _getScrollBarWidth() {\r\n\tconst dummy = document.createElement('div');\r\n\tdummy.style.bottom = '100%';\r\n\tdummy.style.height = '1px';\r\n\tdummy.style.position = 'absolute';\r\n\tdummy.style.width = 'calc(100vw - 100%)';\r\n\tdocument.body.appendChild(dummy);\r\n\tlet width = 0 | window.getComputedStyle(dummy, '').getPropertyValue('width');\r\n\r\n\tif (width === 0) {  // Window does not have any scroll bar\r\n\t\tdummy.style.overflowY = 'scroll';\r\n\t\tdummy.style.width = '';\r\n\t\tconst c = document.createElement('div');\r\n\t\tc.style.minHeight = '100px';\r\n\t\tdummy.appendChild(c);\r\n\t\tconst cw = 0 | window.getComputedStyle(c, '').getPropertyValue('width');\r\n\t\twidth = dummy.offsetWidth - cw;\r\n\t}\r\n\tdocument.body.removeChild(dummy);\r\n\treturn width;\r\n}\r\n"]}