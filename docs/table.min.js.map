{"version":3,"sources":["table.js","_usable-view.js","_neat-width.js"],"names":["window","NACSS","NS","enableClass","enabled","tar","cls","startsWith","dataset","substr","classList","add","remove","throttle","fn","isRunning","args","requestAnimationFrame","makeDummyCell","t","tagName","d","document","createElement","setAttribute","appendChild","removeDummyCell","lt","cMat","removeChild","dcTd","dcTh","isTarget","tab","cMet","rows","length","maxRowSize","cellMinWidth","cellMinAspect","tr","hasChildNodes","n","childNodes","tn","parseInt","getAttribute","cw","clientWidth","ch","clientHeight","onScroll","scrollWidth","r","scrollLeft","styleScrollRight","styleScrollLeft","apply","removeAttribute","style","width","height","grid","css","cs","push","collectCells","maxWidth","Math","max","g","Array","y","gr","tds","i","x","td","col","row","p","q","nr","makeCellGrid","ws","gc","w","HTMLTableCellElement","whiteSpace","minWidth","setCellWidth","met","gw","newWs","fill","fixWs","minW","calcMinWidth","origTabW","origCellWs","wNew","wFix","rem","nw","min","widenTabWidth","calcNewWidths","Object","assign","getMetrics","getElementsByTagName","innerHTML","padH","padV","charW","lineH","cellMinLength","ih","trim","ts","split","map","e","replace","calcMaxLineLength","dc","aw","ls","round","tempW","tempH","tableNeatWidth","tabs","opts","cm","fullWidthRate","maxBorderWidth","before","after","styleNeat","styleFull","s","getComputedStyle","parseFloat","paddingLeft","paddingRight","paddingTop","paddingBottom","elm","nodeName","fontFamily","fontSize","parentNode","h","getTextSize","getCommonMetrics","tarTabs","noTarTabs","gcCount","delay","setTimeout","parentElement","rob","ResizeObserver","oes","oe","target","observe","addEventListener","initScroll","_createHeaderClone","thead","tHead","trs","tBodies","containsOnlyTh","ths","trsH","createTHead","_createPseudoHeader","hc","styleHeaderContainer","ht","styleHeaderTable","cloneNode","_createBarClone","bar","styleScrollBar","spacer","onResize","head","overflowX","tw","getBoundingClientRect","display","top","offset","hw","firstChild","oTrs","cTrs","copyWidth","o","c","tag","os","_updateHeaderSize","disabled","pointerEvents","parent","getPropertyValue","overflowY","minHeight","offsetWidth","getScrollBarWidth","documentElement","_updateScrollBarSize","onWindowScroll","onTableScroll","tBottom","bottom","rh","hTop","hBottom","wY0","wY1","innerHeight","inView","capableWindowHeightRate","tLeft","left","tScrollLeft","hCy","offsetHeight","visible","tabLeft","tabScrollLeft","_updateHeaderVisibility","_updateBarVisibility","sL","tableUsableView","styleFixedHeader","forced","el","op","ro","es","idx","indexOf","contentRect","passive","sel","charAt","toLowerCase","console","log","querySelector"],"mappings":"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","file":"table.min.js","sourcesContent":["/**\n *\n * Table Style (JS)\n *\n * @author Takuto Yanagida\n * @version 2021-01-25\n *\n */\n\n\nwindow.NACSS = window['NACSS'] || {};\n\n\n(function (NS) {\n\n\t(function () {\n\t\t/**\n\t\t *\n\t\t * Neat Width\n\t\t *\n\t\t * @author Takuto Yanagida\n\t\t * @version 2021-01-25\n\t\t *\n\t\t */\n\t\t\n\t\t\n\t\tfunction initialize(tabs, opts = {}) {\n\t\t\tif (tabs.length === 0) return;\n\t\t\n\t\t\tconst lt = tabs[tabs.length - 1];\n\t\t\tconst cm = Object.assign({\n\t\t\t\tfullWidthRate   : 0.95,\n\t\t\t\tcellMinWidth    : 80,\n\t\t\t\tcellMinAspect   : 2 / 3,  // width / height\n\t\t\t\tcellMinLength   : 8,\n\t\t\t\tmaxRowSize      : 200,\n\t\t\t\tmaxBorderWidth  : 2,\n\t\t\t\tbefore          : null,  // function (table) { ...; return delay; }\n\t\t\t\tafter           : null,  // function (table) { ... }\n\t\t\t\tstyleNeat       : ':ncTableNeat',\n\t\t\t\tstyleFull       : ':ncTableFull',\n\t\t\t\tstyleScrollRight: ':ncScrollRight',\n\t\t\t\tstyleScrollLeft : ':ncScrollLeft',\n\t\t\t}, opts, getCommonMetrics(lt));\n\t\t\n\t\t\tcm.padH += cm.maxBorderWidth * 2;\n\t\t\tcm.padV += cm.maxBorderWidth * 2;\n\t\t\tcm.dcTd = makeDummyCell(lt, 'td');\n\t\t\tcm.dcTh = makeDummyCell(lt, 'th');\n\t\t\n\t\t\tconst tarTabs = [], noTarTabs = [];\n\t\t\tfor (const t of tabs) {\n\t\t\t\tif (isTarget(t, cm)) tarTabs.push(t);\n\t\t\t\telse noTarTabs.push(t);\n\t\t\t}\n\t\t\tcm.gcCount = tarTabs.length;\n\t\t\n\t\t\tfor (const t of tarTabs) {\n\t\t\t\tconst delay = (cm.before) ? (cm.before(t) ?? 0) : false;\n\t\t\t\tst(() => {\n\t\t\t\t\tapply(t, cm);\n\t\t\t\t\tenableClass(true, t, cm.styleNeat);\n\t\t\t\t\tif (cm.after) cm.after(t);\n\t\t\t\t\tif (--cm.gcCount === 0) removeDummyCell(lt, cm);\n\t\t\t\t}, delay);\n\t\t\t}\n\t\t\tif (cm.fullWidthRate) {\n\t\t\t\tfor (const t of noTarTabs) {\n\t\t\t\t\tconst pw = t.parentElement.clientWidth;\n\t\t\t\t\tif (pw * cm.fullWidthRate < t.clientWidth) enableClass(true, t, cm.styleFull);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfunction st(fn, d) { (d === false) ? fn() : setTimeout(fn, d); }\n\t\t\tinitScroll(tarTabs, cm);\n\t\t}\n\t\t\n\t\tfunction getCommonMetrics(tab) {\n\t\t\tconst td = tab.getElementsByTagName('td')[0];\n\t\t\tconst s = getComputedStyle(td);\n\t\t\tconst padH  = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);\n\t\t\tconst padV  = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);\n\t\t\tconst [charW, lineH] = getTextSize(td);\n\t\t\treturn { padH, padV, charW, lineH };\n\t\t}\n\t\t\n\t\tfunction getTextSize(elm) {\n\t\t\tconst d = document.createElement(elm.nodeName);\n\t\t\td.setAttribute('style', `position:fixed;margin:0;padding:0;font-family:${elm.style.fontFamily || 'inherit'};font-size:${elm.style.fontSize || 'inherit'};`);\n\t\t\td.innerHTML = '\\u3000';  // Full width space\n\t\t\telm.parentNode.appendChild(d);\n\t\t\tconst w = d.clientWidth;\n\t\t\tconst h = d.clientHeight;\n\t\t\td.parentNode.removeChild(d);\n\t\t\treturn [w, h];\n\t\t}\n\t\t\n\t\tfunction makeDummyCell(t, tagName) {\n\t\t\tconst d = document.createElement(tagName);\n\t\t\td.setAttribute('style', `position:fixed;display:inline-block;visibility:hidden;white-space:nowrap;`);\n\t\t\treturn t.appendChild(d);\n\t\t}\n\t\t\n\t\tfunction removeDummyCell(lt, cMat) {\n\t\t\tlt.removeChild(cMat.dcTd);\n\t\t\tlt.removeChild(cMat.dcTh);\n\t\t}\n\t\t\n\t\tfunction isTarget(tab, cMet) {\n\t\t\tif (tab.rows.length === 0) return false;\n\t\t\tif (cMet.maxRowSize < tab.rows.length) return false;\n\t\t\n\t\t\tconst { cellMinWidth, cellMinAspect } = cMet;\n\t\t\tfor (const tr of tab.rows) {\n\t\t\t\tif (!tr.hasChildNodes()) continue;\n\t\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\t\tconst tn = n.tagName;\n\t\t\t\t\tif (tn !== 'TD' && tn !== 'TH') continue;\n\t\t\t\t\tif (1 < parseInt(n.getAttribute('colSpan'), 10)) continue;\n\t\t\t\t\tif (1 < parseInt(n.getAttribute('rowSpan'), 10)) continue;\n\t\t\t\t\tconst cw = n.clientWidth;\n\t\t\t\t\tconst ch = n.clientHeight;\n\t\t\t\t\tif (cw < cellMinWidth || cw / ch < cellMinAspect) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction initScroll(tabs, cMet) {\n\t\t\tconst rob = new ResizeObserver(oes => {\n\t\t\t\tfor (const oe of oes) onScroll(oe.target, cMet);\n\t\t\t});\n\t\t\tfor (const t of tabs) {\n\t\t\t\trob.observe(t);\n\t\t\t\tt.addEventListener('scroll', throttle(() => { onScroll(t, cMet); }));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfunction onScroll(tab, cMet) {\n\t\t\tif (tab.scrollWidth - tab.clientWidth > 2) {  // for avoiding needless scrolling\n\t\t\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\n\t\t\t\tenableClass(r < 0.95, tab, cMet.styleScrollRight);\n\t\t\t\tenableClass(0.05 < r, tab, cMet.styleScrollLeft);\n\t\t\t} else {\n\t\t\t\tenableClass(false, tab, cMet.styleScrollRight);\n\t\t\t\tenableClass(false, tab, cMet.styleScrollLeft);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction apply(tab, cMet) {\n\t\t\ttab.removeAttribute('width');\n\t\t\tif (tab.style.width) tab.style.width = null;\n\t\t\tif (tab.style.height) tab.style.height = null;\n\t\t\n\t\t\tconst grid  = makeCellGrid(tab);\n\t\t\tconst met   = Object.assign(getMetrics(tab, grid), cMet);\n\t\t\tconst newWs = calcNewWidths(grid, met);\n\t\t\tsetCellWidth(grid, newWs);\n\t\t\n\t\t\tconst cs = tab.getElementsByTagName('caption');\n\t\t\tif (cs.length) cs[0].innerHTML = `<span>${cs[0].innerHTML}</span>`;\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction makeCellGrid(t) {\n\t\t\tconst css = collectCells(t);\n\t\t\tlet maxWidth = 0;\n\t\t\tfor (const cs of css) maxWidth = Math.max(maxWidth, cs.length);\n\t\t\tconst g = [];\n\t\t\tfor (const cs of css) g.push(new Array(maxWidth));\n\t\t\n\t\t\tfor (let y = 0; y < g.length; y += 1) {\n\t\t\t\tconst gr = g[y];\n\t\t\t\tconst tds = css[y];\n\t\t\t\tlet i = 0;\n\t\t\n\t\t\t\tfor (let x = 0; x < maxWidth; x += 1) {\n\t\t\t\t\tif (typeof gr[x] === 'number' || gr[x] === null) continue;\n\t\t\n\t\t\t\t\tconst td = tds[i]\n\t\t\t\t\tconst col = parseInt(td.getAttribute('colSpan') ?? 1, 10);\n\t\t\t\t\tconst row = parseInt(td.getAttribute('rowSpan') ?? 1, 10);\n\t\t\t\t\tgr[x] = td;\n\t\t\n\t\t\t\t\tif (1 < col) {\n\t\t\t\t\t\tfor (let p = 1; p < col; p += 1) gr[x + p] = p;\n\t\t\t\t\t}\n\t\t\t\t\tif (1 < row) {\n\t\t\t\t\t\tfor (let q = 1; q < row; q += 1) {\n\t\t\t\t\t\t\tconst nr = g[y + q];\n\t\t\t\t\t\t\tfor (let p = 0; p < col; p += 1) nr[x + p] = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti += 1;\n\t\t\t\t\tif (tds.length <= i) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\t\n\t\tfunction collectCells(t, css = []) {\n\t\t\tfor (const tr of t.rows) {\n\t\t\t\tconst cs = [];\n\t\t\t\tif (tr.hasChildNodes()) {\n\t\t\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\t\t\tconst tn = n.tagName;\n\t\t\t\t\t\tif (tn === 'TD' || tn === 'TH') cs.push(n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcss.push(cs);\n\t\t\t}\n\t\t\treturn css;\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction getMetrics(tab, grid) {\n\t\t\tconst origTabW = tab.clientWidth;\n\t\t\tconst origCellWs = [];\n\t\t\tfor (let x = 0; x < grid[0].length; x += 1) {\n\t\t\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\t\t\tconst g = grid[y][x];\n\t\t\t\t\tif (g instanceof HTMLTableCellElement && !g.getAttribute('colSpan')) {\n\t\t\t\t\t\torigCellWs.push(g.clientWidth);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn { origTabW, origCellWs };\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction calcNewWidths(grid, met) {\n\t\t\tfor (const gr of grid) {\n\t\t\t\tfor (const gc of gr) {\n\t\t\t\t\tif (typeof gc !== 'number' && gc !== null) gc.style.whiteSpace = 'nowrap';\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst gw = grid[0].length;\n\t\t\tconst newWs = new Array(gw).fill(0);\n\t\t\tconst fixWs = new Array(gw).fill(0);\n\t\t\n\t\t\tfor (const gr of grid) {\n\t\t\t\tfor (let x = 0; x < gw; x += 1) {\n\t\t\t\t\tconst td = gr[x];\n\t\t\t\t\tif (td === undefined || td === null || typeof td === 'number') continue;\n\t\t\t\t\tif (x < gw - 1 && typeof gr[x + 1] === 'number') continue;\n\t\t\t\t\tif (1 < parseInt(td.getAttribute('colSpan'), 10)) continue;\n\t\t\t\t\tif (1 < parseInt(td.getAttribute('rowSpan'), 10)) continue;\n\t\t\n\t\t\t\t\tconst minW = calcMinWidth(td, met);\n\t\t\t\t\tnewWs[x] = Math.max(newWs[x], minW);\n\t\t\t\t\tif (!minW) fixWs[x] = Math.max(fixWs[x], td.clientWidth);\n\t\t\t\t}\n\t\t\t}\n\t\t\twidenTabWidth(newWs, fixWs, met);\n\t\t\treturn newWs;\n\t\t}\n\t\t\n\t\tfunction calcMinWidth(td, met) {\n\t\t\tconst { padH, padV, charW, lineH, dcTd, dcTh, cellMinWidth, cellMinAspect, cellMinLength } = met;\n\t\t\tif (calcMaxLineLength(td) < cellMinLength) return 0;\n\t\t\n\t\t\ttd.innerHTML = td.innerHTML.trim();\n\t\t\tconst dc = td.tagName === 'TD' ? dcTd : dcTh;\n\t\t\tdc.innerHTML = td.innerHTML;\n\t\t\tconst aw = dc.clientWidth - padH;\n\t\t\tconst ls = Math.round((dc.clientHeight - padV) / lineH);\n\t\t\tlet minW = 0;\n\t\t\tfor (let i = 2;; i += 1) {\n\t\t\t\tconst tempW = 0 | (aw / i + charW * i + padH);\n\t\t\t\tconst tempH = ls * (i * lineH) + padV;\n\t\t\t\tif (tempW < cellMinWidth || tempW / tempH < cellMinAspect || (minW && minW < tempW)) break;\n\t\t\t\tminW = tempW;\n\t\t\t}\n\t\t\treturn (minW + charW < dc.clientWidth) ? minW : 0;\n\t\t}\n\t\t\n\t\tfunction calcMaxLineLength(td) {\n\t\t\tconst ih = td.innerHTML.trim();\n\t\t\tconst ls = ih.split(/<\\s*br\\s*\\/?>/ui);\n\t\t\tconst ts = ls.map(e => e.replace(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/g, '').length);\n\t\t\treturn Math.max(...ts);\n\t\t}\n\t\t\n\t\tfunction widenTabWidth(newWs, fixWs, met) {\n\t\t\tconst { origTabW, origCellWs } = met;\n\t\t\tlet wNew = 0, wFix = 0;\n\t\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\t\tif (newWs[i]) {\n\t\t\t\t\twNew += newWs[i];\n\t\t\t\t} else {\n\t\t\t\t\twFix += fixWs[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (origTabW < wNew + wFix) return;\n\t\t\tlet rem = origTabW - wFix;\n\t\t\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\t\t\tif (!newWs[i]) continue;\n\t\t\t\tconst nw = newWs[i];\n\t\t\t\tconst w = Math.min(nw / wNew * rem, origCellWs[i]);\n\t\t\t\trem  -= (w - nw);\n\t\t\t\twNew -= (w - nw);\n\t\t\t\tnewWs[i] = 0 | w;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t// -------------------------------------------------------------------------\n\t\t\n\t\t\n\t\tfunction setCellWidth(grid, ws) {\n\t\t\tfor (const gr of grid) {\n\t\t\t\tfor (let x = 0; x < gr.length; x += 1) {\n\t\t\t\t\tconst gc = gr[x], w = ws[x];\n\t\t\t\t\tif (!w || !(gc instanceof HTMLTableCellElement)) continue;\n\t\t\t\t\tgc.style.whiteSpace = null;\n\t\t\t\t\tgc.style.minWidth   = w + 'px';\n\t\t\t\t\tgc.style.width      = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tNS.tableNeatWidth = initialize;\n\t})();\n\n\t(function () {\n\t\t/**\r\n\t\t *\r\n\t\t * Usable View\r\n\t\t *\r\n\t\t * @author Takuto Yanagida\r\n\t\t * @version 2021-01-25\r\n\t\t *\r\n\t\t */\r\n\t\t\r\n\t\t\r\n\t\tfunction initialize(tabs, opts = {}) {\r\n\t\t\tif (tabs.length === 0) return;\r\n\t\t\tconst cm = Object.assign({\r\n\t\t\t\tcapableWindowHeightRate: 0.9,\r\n\t\t\t\tstyleHeaderContainer   : ':fixedTableHeaderContainer',\r\n\t\t\t\tstyleHeaderTable       : ':fixedTableHeaderTable',\r\n\t\t\t\tstyleScrollBar         : ':fixedTableScrollBar',\r\n\t\t\t\tstyleFixedHeader       : ':ncFixedHeader',\r\n\t\t\r\n\t\t\t\tstyleScrollRight       : ':ncScrollRight',\r\n\t\t\t\tstyleScrollLeft        : ':ncScrollLeft',\r\n\t\t\t\toffset                 : 0,\r\n\t\t\t}, opts);\r\n\t\t\r\n\t\t\tconst cs = [], ts = [...tabs];\r\n\t\t\tfor (const tab of ts) {\r\n\t\t\t\tconst head = _createHeaderClone(tab, cm);\r\n\t\t\t\tconst bar  = _createBarClone(tab, cm);\r\n\t\t\t\tcs.push({ tab, head, bar });\r\n\t\t\r\n\t\t\t\tlet forced = false;\r\n\t\t\t\tconst el = (tar, op) => throttle(() => {\r\n\t\t\t\t\tif (forced) {\r\n\t\t\t\t\t\tforced = false;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tforced = true;\r\n\t\t\t\t\t\top.scrollLeft = tar.scrollLeft;\r\n\t\t\t\t\t\tif (head) onTableScroll(tab, head, cm);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\ttab.addEventListener('scroll', el(tab, bar));\r\n\t\t\t\tbar.addEventListener('scroll', el(bar, tab));\r\n\t\t\t}\r\n\t\t\tconst ro = new ResizeObserver((es) => {\r\n\t\t\t\tfor (const e of es) {\r\n\t\t\t\t\tconst idx = ts.indexOf(e.target);\r\n\t\t\t\t\tconst c = cs[idx];\r\n\t\t\t\t\tonResize(e.contentRect, c.tab, c.head, c.bar, cm);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tfor (const t of ts) ro.observe(t);\r\n\t\t\r\n\t\t\twindow.addEventListener('scroll', throttle(() => {\r\n\t\t\t\tfor (const c of cs) onWindowScroll(c.tab, c.head, c.bar, cm);\r\n\t\t\t}), { passive: true });\r\n\t\t\r\n\t\t\tconst sel = getSelector(cm.styleFixedHeader);\r\n\t\t\tif (sel) {\r\n\t\t\t\tconsole.log(sel);\r\n\t\t\t\tconst elm = document.querySelector(sel);\r\n\t\t\t\tif (elm) {\r\n\t\t\t\t\tconst rob = new ResizeObserver(es => {\r\n\t\t\t\t\t\tcm.offset = es[0].contentRect.bottom;\r\n\t\t\t\t\t\tfor (const c of cs) onResize(null, c.tab, c.head, c.bar, cm);\r\n\t\t\t\t\t});\r\n\t\t\t\t\trob.observe(elm);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfunction _createHeaderClone(tab, cm) {\r\n\t\t\tlet thead = tab.tHead;\r\n\t\t\tif (!thead) {\r\n\t\t\t\tthead = _createPseudoHeader(tab);\r\n\t\t\t\tif (!thead) return null;\r\n\t\t\t\ttab.tHead = thead;\r\n\t\t\t}\r\n\t\t\tconst hc = document.createElement('div');\r\n\t\t\tenableClass(true, hc, cm.styleHeaderContainer);\r\n\t\t\ttab.parentNode.appendChild(hc);\r\n\t\t\r\n\t\t\tconst ht = document.createElement('div');\r\n\t\t\tenableClass(true, ht, cm.styleHeaderTable);\r\n\t\t\thc.appendChild(ht);\r\n\t\t\r\n\t\t\tht.appendChild(thead.cloneNode(true));\r\n\t\t\treturn hc;\r\n\t\t}\r\n\t\t\r\n\t\tfunction _createPseudoHeader(tab) {\r\n\t\t\tconst trs = tab.tBodies[0].rows;\r\n\t\t\tif (trs.length === 0) return null;\r\n\t\t\r\n\t\t\tfunction containsOnlyTh(tr) {\r\n\t\t\t\tconst tds = tr.getElementsByTagName('td');\r\n\t\t\t\tconst ths = tr.getElementsByTagName('th');\r\n\t\t\t\tif (tds.length === 0 && ths.length > 0) return true;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tconst trsH = [];\r\n\t\t\tfor (const tr of trs) {\r\n\t\t\t\tif (!containsOnlyTh(tr)) break;\r\n\t\t\t\ttrsH.push(tr);\r\n\t\t\t}\r\n\t\t\tif (trsH.length === 0) return null;\r\n\t\t\r\n\t\t\tconst thead = tab.createTHead();\r\n\t\t\tfor (const tr of trsH) thead.appendChild(tr);\r\n\t\t\treturn thead;\r\n\t\t}\r\n\t\t\r\n\t\tfunction _createBarClone(tab, cm) {\r\n\t\t\tconst bar = document.createElement('div');\r\n\t\t\tenableClass(true, bar, cm.styleScrollBar);\r\n\t\t\tconst spacer = document.createElement('div');\r\n\t\t\tbar.appendChild(spacer);\r\n\t\t\ttab.parentNode.appendChild(bar);\r\n\t\t\treturn bar;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t// ---------------------------------------------------------------------\r\n\t\t\r\n\t\t\r\n\t\tfunction onResize(r, tab, head, bar, cm) {\r\n\t\t\ttab.style.overflowX = (tab.scrollWidth < tab.clientWidth + 2) ? 'hidden' : null;\r\n\t\t\r\n\t\t\tif (head) _updateHeaderSize(r, tab, head, cm);\r\n\t\t\tif (bar) _updateScrollBarSize(tab, bar);\r\n\t\t\tif (head || bar) onWindowScroll(tab, head, bar, cm);\r\n\t\t\tif (head) onTableScroll(tab, head, cm);\r\n\t\t}\r\n\t\t\r\n\t\tfunction _updateHeaderSize(r, tab, head, cm) {\r\n\t\t\tconst tw = r ? r.width : tab.getBoundingClientRect().width;\r\n\t\t\thead.style.maxWidth = tw + 'px';\r\n\t\t\thead.style.display  = 'none';\r\n\t\t\thead.style.top      = cm.offset + 'px';\r\n\t\t\r\n\t\t\tconst thead = tab.tHead;\r\n\t\t\tconst hw = thead.getBoundingClientRect().width;\r\n\t\t\tconst ht = head.firstChild;\r\n\t\t\tht.style.width = hw + 'px';\r\n\t\t\r\n\t\t\tconst oTrs = thead.rows;\r\n\t\t\tconst cTrs = ht.firstChild.rows;\r\n\t\t\tfor (let i = 0; i < oTrs.length; i += 1) {\r\n\t\t\t\tcopyWidth(oTrs[i], cTrs[i], 'td');\r\n\t\t\t\tcopyWidth(oTrs[i], cTrs[i], 'th');\r\n\t\t\t}\r\n\t\t\tfunction copyWidth(o, c, tag) {\r\n\t\t\t\tconst os = o.getElementsByTagName(tag);\r\n\t\t\t\tconst cs = c.getElementsByTagName(tag);\r\n\t\t\t\tfor (let i = 0; i < os.length; i += 1) {\r\n\t\t\t\t\tcs[i].style.width = os[i].getBoundingClientRect().width + 'px';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfunction _updateScrollBarSize(tab, bar) {\r\n\t\t\tconst disabled = (tab.scrollWidth < tab.clientWidth + 2);\r\n\t\t\tbar.style.overflowX = disabled ? 'hidden' : null;\r\n\t\t\tbar.style.pointerEvents = disabled ? 'none' : null;\r\n\t\t\r\n\t\t\tbar.style.maxWidth = `${tab.clientWidth}px`;\r\n\t\t\tbar.style.display = 'none';\r\n\t\t\tconst h = parseInt(getScrollBarWidth(document.documentElement));\r\n\t\t\tif (0 < h) bar.style.height = (h + 2) + 'px';\r\n\t\t\tbar.firstChild.style.width = `${tab.scrollWidth}px`;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t// ---------------------------------------------------------------------\r\n\t\t\r\n\t\t\r\n\t\tfunction onWindowScroll(tab, head, bar, cm) {\r\n\t\t\tconst r = tab.getBoundingClientRect();\r\n\t\t\tconst tBottom = r.bottom;\r\n\t\t\tconst rh = tab.tHead.getBoundingClientRect();\r\n\t\t\tconst hTop = rh.top, hBottom = rh.bottom;\r\n\t\t\tconst wY0 = cm.offset, wY1 = window.innerHeight;\r\n\t\t\r\n\t\t\tconst inView = tBottom - hTop < cm.capableWindowHeightRate * (wY1 - wY0);\r\n\t\t\tconst tLeft = r.left, tScrollLeft = tab.scrollLeft;\r\n\t\t\tif (head) {\r\n\t\t\t\tconst hCy = tab.tHead.offsetHeight;\r\n\t\t\t\tconst f = (!inView && hTop < wY0 && wY0 < tBottom - hCy);\r\n\t\t\t\t_updateHeaderVisibility(head, f, tLeft, tScrollLeft);\r\n\t\t\t}\r\n\t\t\tif (bar) {\r\n\t\t\t\tconst f = (!inView && hBottom < wY1 && wY1 < tBottom);\r\n\t\t\t\t_updateBarVisibility(bar, f, tLeft, tScrollLeft);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfunction _updateHeaderVisibility(head, visible, tabLeft, tabScrollLeft) {\r\n\t\t\thead.style.display = visible ? 'block' : 'none';\r\n\t\t\thead.style.left    = tabLeft + 'px';\r\n\t\t\thead.scrollLeft    = tabScrollLeft;\r\n\t\t}\r\n\t\t\r\n\t\tfunction _updateBarVisibility(bar, visible, tabLeft, tabScrollLeft) {\r\n\t\t\tbar.style.display = visible ? 'block' : 'none';\r\n\t\t\tbar.style.left    = tabLeft + 'px';\r\n\t\t\tbar.scrollLeft    = tabScrollLeft;\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t// ---------------------------------------------------------------------\r\n\t\t\r\n\t\t\r\n\t\tfunction onTableScroll(tab, head, cm) {\r\n\t\t\tconst sL = Math.max(0, Math.min(tab.scrollLeft, tab.scrollWidth - tab.offsetWidth));  // for iOS\r\n\t\t\thead.scrollLeft = sL;\r\n\t\t\r\n\t\t\tif (tab.scrollWidth - tab.clientWidth > 2) {  // for avoiding needless scrolling\r\n\t\t\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\r\n\t\t\t\tenableClass(r < 0.95, head, cm.styleScrollRight);\r\n\t\t\t\tenableClass(0.05 < r, head, cm.styleScrollLeft);\r\n\t\t\t} else {\r\n\t\t\t\tenableClass(false, head, cm.styleScrollRight);\r\n\t\t\t\tenableClass(false, head, cm.styleScrollLeft);\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t// Utilities ---------------------------------------------------------------\r\n\t\t\r\n\t\t\r\n\t\tfunction getSelector(cls) {\r\n\t\t\tif (cls.startsWith(':')) {\r\n\t\t\t\treturn `*[data-${cls.substr(1).replace(/([A-Z])/g, c => '-' + c.charAt(0).toLowerCase())}]`;\r\n\t\t\t} else {\r\n\t\t\t\treturn `*${cls}`;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tfunction getScrollBarWidth(parent) {\r\n\t\t\tconst d = document.createElement('div');\r\n\t\t\td.setAttribute('style', 'position:absolute;bottom:100%;width:calc(100vw - 100%);height:1px;');\r\n\t\t\tparent.appendChild(d);\r\n\t\t\tlet width = 0 | window.getComputedStyle(d).getPropertyValue('width');\r\n\t\t\r\n\t\t\tif (width === 0) {  // Window does not have any scroll bar\r\n\t\t\t\td.style.overflowY = 'scroll';\r\n\t\t\t\td.style.width = '';\r\n\t\t\t\tconst c = document.createElement('div');\r\n\t\t\t\tc.style.minHeight = '100px';\r\n\t\t\t\td.appendChild(c);\r\n\t\t\t\tconst cw = 0 | window.getComputedStyle(c).getPropertyValue('width');\r\n\t\t\t\twidth = d.offsetWidth - cw;\r\n\t\t\t}\r\n\t\t\tparent.removeChild(d);\r\n\t\t\treturn width;\r\n\t\t}\n\t\tNS.tableUsableView = initialize;\n\t})();\n\n\t/**\r\n\t *\r\n\t * Utilities\r\n\t *\r\n\t * @author Takuto Yanagida\r\n\t * @version 2021-01-25\r\n\t *\r\n\t */\r\n\t\r\n\t\r\n\tfunction enableClass(enabled, tar, cls) {\r\n\t\tif (enabled) {\r\n\t\t\tif (cls.startsWith(':')) tar.dataset[cls.substr(1)] = '';\r\n\t\t\telse tar.classList.add(cls.substr(1));\r\n\t\t} else {\r\n\t\t\tif (cls.startsWith(':')) delete tar.dataset[cls.substr(1)];\r\n\t\t\telse tar.classList.remove(cls.substr(1));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction throttle(fn) {\r\n\t\tlet isRunning;\r\n\t\treturn (...args) => {\r\n\t\t\tif (isRunning) return;\r\n\t\t\tisRunning = true;\r\n\t\t\trequestAnimationFrame(() => {\r\n\t\t\t\tisRunning = false;\r\n\t\t\t\tfn(...args);\r\n\t\t\t});\r\n\t\t};\r\n\t}\n\n})(window.NACSS);\n","/**\r\n *\r\n * Usable View\r\n *\r\n * @author Takuto Yanagida\r\n * @version 2021-01-25\r\n *\r\n */\r\n\r\n\r\nfunction initialize(tabs, opts = {}) {\r\n\tif (tabs.length === 0) return;\r\n\tconst cm = Object.assign({\r\n\t\tcapableWindowHeightRate: 0.9,\r\n\t\tstyleHeaderContainer   : ':fixedTableHeaderContainer',\r\n\t\tstyleHeaderTable       : ':fixedTableHeaderTable',\r\n\t\tstyleScrollBar         : ':fixedTableScrollBar',\r\n\t\tstyleFixedHeader       : ':ncFixedHeader',\r\n\r\n\t\tstyleScrollRight       : ':ncScrollRight',\r\n\t\tstyleScrollLeft        : ':ncScrollLeft',\r\n\t\toffset                 : 0,\r\n\t}, opts);\r\n\r\n\tconst cs = [], ts = [...tabs];\r\n\tfor (const tab of ts) {\r\n\t\tconst head = _createHeaderClone(tab, cm);\r\n\t\tconst bar  = _createBarClone(tab, cm);\r\n\t\tcs.push({ tab, head, bar });\r\n\r\n\t\tlet forced = false;\r\n\t\tconst el = (tar, op) => throttle(() => {\r\n\t\t\tif (forced) {\r\n\t\t\t\tforced = false;\r\n\t\t\t} else {\r\n\t\t\t\tforced = true;\r\n\t\t\t\top.scrollLeft = tar.scrollLeft;\r\n\t\t\t\tif (head) onTableScroll(tab, head, cm);\r\n\t\t\t}\r\n\t\t});\r\n\t\ttab.addEventListener('scroll', el(tab, bar));\r\n\t\tbar.addEventListener('scroll', el(bar, tab));\r\n\t}\r\n\tconst ro = new ResizeObserver((es) => {\r\n\t\tfor (const e of es) {\r\n\t\t\tconst idx = ts.indexOf(e.target);\r\n\t\t\tconst c = cs[idx];\r\n\t\t\tonResize(e.contentRect, c.tab, c.head, c.bar, cm);\r\n\t\t}\r\n\t});\r\n\tfor (const t of ts) ro.observe(t);\r\n\r\n\twindow.addEventListener('scroll', throttle(() => {\r\n\t\tfor (const c of cs) onWindowScroll(c.tab, c.head, c.bar, cm);\r\n\t}), { passive: true });\r\n\r\n\tconst sel = getSelector(cm.styleFixedHeader);\r\n\tif (sel) {\r\n\t\tconsole.log(sel);\r\n\t\tconst elm = document.querySelector(sel);\r\n\t\tif (elm) {\r\n\t\t\tconst rob = new ResizeObserver(es => {\r\n\t\t\t\tcm.offset = es[0].contentRect.bottom;\r\n\t\t\t\tfor (const c of cs) onResize(null, c.tab, c.head, c.bar, cm);\r\n\t\t\t});\r\n\t\t\trob.observe(elm);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction _createHeaderClone(tab, cm) {\r\n\tlet thead = tab.tHead;\r\n\tif (!thead) {\r\n\t\tthead = _createPseudoHeader(tab);\r\n\t\tif (!thead) return null;\r\n\t\ttab.tHead = thead;\r\n\t}\r\n\tconst hc = document.createElement('div');\r\n\tenableClass(true, hc, cm.styleHeaderContainer);\r\n\ttab.parentNode.appendChild(hc);\r\n\r\n\tconst ht = document.createElement('div');\r\n\tenableClass(true, ht, cm.styleHeaderTable);\r\n\thc.appendChild(ht);\r\n\r\n\tht.appendChild(thead.cloneNode(true));\r\n\treturn hc;\r\n}\r\n\r\nfunction _createPseudoHeader(tab) {\r\n\tconst trs = tab.tBodies[0].rows;\r\n\tif (trs.length === 0) return null;\r\n\r\n\tfunction containsOnlyTh(tr) {\r\n\t\tconst tds = tr.getElementsByTagName('td');\r\n\t\tconst ths = tr.getElementsByTagName('th');\r\n\t\tif (tds.length === 0 && ths.length > 0) return true;\r\n\t\treturn false;\r\n\t}\r\n\tconst trsH = [];\r\n\tfor (const tr of trs) {\r\n\t\tif (!containsOnlyTh(tr)) break;\r\n\t\ttrsH.push(tr);\r\n\t}\r\n\tif (trsH.length === 0) return null;\r\n\r\n\tconst thead = tab.createTHead();\r\n\tfor (const tr of trsH) thead.appendChild(tr);\r\n\treturn thead;\r\n}\r\n\r\nfunction _createBarClone(tab, cm) {\r\n\tconst bar = document.createElement('div');\r\n\tenableClass(true, bar, cm.styleScrollBar);\r\n\tconst spacer = document.createElement('div');\r\n\tbar.appendChild(spacer);\r\n\ttab.parentNode.appendChild(bar);\r\n\treturn bar;\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------\r\n\r\n\r\nfunction onResize(r, tab, head, bar, cm) {\r\n\ttab.style.overflowX = (tab.scrollWidth < tab.clientWidth + 2) ? 'hidden' : null;\r\n\r\n\tif (head) _updateHeaderSize(r, tab, head, cm);\r\n\tif (bar) _updateScrollBarSize(tab, bar);\r\n\tif (head || bar) onWindowScroll(tab, head, bar, cm);\r\n\tif (head) onTableScroll(tab, head, cm);\r\n}\r\n\r\nfunction _updateHeaderSize(r, tab, head, cm) {\r\n\tconst tw = r ? r.width : tab.getBoundingClientRect().width;\r\n\thead.style.maxWidth = tw + 'px';\r\n\thead.style.display  = 'none';\r\n\thead.style.top      = cm.offset + 'px';\r\n\r\n\tconst thead = tab.tHead;\r\n\tconst hw = thead.getBoundingClientRect().width;\r\n\tconst ht = head.firstChild;\r\n\tht.style.width = hw + 'px';\r\n\r\n\tconst oTrs = thead.rows;\r\n\tconst cTrs = ht.firstChild.rows;\r\n\tfor (let i = 0; i < oTrs.length; i += 1) {\r\n\t\tcopyWidth(oTrs[i], cTrs[i], 'td');\r\n\t\tcopyWidth(oTrs[i], cTrs[i], 'th');\r\n\t}\r\n\tfunction copyWidth(o, c, tag) {\r\n\t\tconst os = o.getElementsByTagName(tag);\r\n\t\tconst cs = c.getElementsByTagName(tag);\r\n\t\tfor (let i = 0; i < os.length; i += 1) {\r\n\t\t\tcs[i].style.width = os[i].getBoundingClientRect().width + 'px';\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction _updateScrollBarSize(tab, bar) {\r\n\tconst disabled = (tab.scrollWidth < tab.clientWidth + 2);\r\n\tbar.style.overflowX = disabled ? 'hidden' : null;\r\n\tbar.style.pointerEvents = disabled ? 'none' : null;\r\n\r\n\tbar.style.maxWidth = `${tab.clientWidth}px`;\r\n\tbar.style.display = 'none';\r\n\tconst h = parseInt(getScrollBarWidth(document.documentElement));\r\n\tif (0 < h) bar.style.height = (h + 2) + 'px';\r\n\tbar.firstChild.style.width = `${tab.scrollWidth}px`;\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------\r\n\r\n\r\nfunction onWindowScroll(tab, head, bar, cm) {\r\n\tconst r = tab.getBoundingClientRect();\r\n\tconst tBottom = r.bottom;\r\n\tconst rh = tab.tHead.getBoundingClientRect();\r\n\tconst hTop = rh.top, hBottom = rh.bottom;\r\n\tconst wY0 = cm.offset, wY1 = window.innerHeight;\r\n\r\n\tconst inView = tBottom - hTop < cm.capableWindowHeightRate * (wY1 - wY0);\r\n\tconst tLeft = r.left, tScrollLeft = tab.scrollLeft;\r\n\tif (head) {\r\n\t\tconst hCy = tab.tHead.offsetHeight;\r\n\t\tconst f = (!inView && hTop < wY0 && wY0 < tBottom - hCy);\r\n\t\t_updateHeaderVisibility(head, f, tLeft, tScrollLeft);\r\n\t}\r\n\tif (bar) {\r\n\t\tconst f = (!inView && hBottom < wY1 && wY1 < tBottom);\r\n\t\t_updateBarVisibility(bar, f, tLeft, tScrollLeft);\r\n\t}\r\n}\r\n\r\nfunction _updateHeaderVisibility(head, visible, tabLeft, tabScrollLeft) {\r\n\thead.style.display = visible ? 'block' : 'none';\r\n\thead.style.left    = tabLeft + 'px';\r\n\thead.scrollLeft    = tabScrollLeft;\r\n}\r\n\r\nfunction _updateBarVisibility(bar, visible, tabLeft, tabScrollLeft) {\r\n\tbar.style.display = visible ? 'block' : 'none';\r\n\tbar.style.left    = tabLeft + 'px';\r\n\tbar.scrollLeft    = tabScrollLeft;\r\n}\r\n\r\n\r\n// ---------------------------------------------------------------------\r\n\r\n\r\nfunction onTableScroll(tab, head, cm) {\r\n\tconst sL = Math.max(0, Math.min(tab.scrollLeft, tab.scrollWidth - tab.offsetWidth));  // for iOS\r\n\thead.scrollLeft = sL;\r\n\r\n\tif (tab.scrollWidth - tab.clientWidth > 2) {  // for avoiding needless scrolling\r\n\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\r\n\t\tenableClass(r < 0.95, head, cm.styleScrollRight);\r\n\t\tenableClass(0.05 < r, head, cm.styleScrollLeft);\r\n\t} else {\r\n\t\tenableClass(false, head, cm.styleScrollRight);\r\n\t\tenableClass(false, head, cm.styleScrollLeft);\r\n\t}\r\n}\r\n\r\n\r\n// Utilities ---------------------------------------------------------------\r\n\r\n\r\nfunction getSelector(cls) {\r\n\tif (cls.startsWith(':')) {\r\n\t\treturn `*[data-${cls.substr(1).replace(/([A-Z])/g, c => '-' + c.charAt(0).toLowerCase())}]`;\r\n\t} else {\r\n\t\treturn `*${cls}`;\r\n\t}\r\n}\r\n\r\nfunction getScrollBarWidth(parent) {\r\n\tconst d = document.createElement('div');\r\n\td.setAttribute('style', 'position:absolute;bottom:100%;width:calc(100vw - 100%);height:1px;');\r\n\tparent.appendChild(d);\r\n\tlet width = 0 | window.getComputedStyle(d).getPropertyValue('width');\r\n\r\n\tif (width === 0) {  // Window does not have any scroll bar\r\n\t\td.style.overflowY = 'scroll';\r\n\t\td.style.width = '';\r\n\t\tconst c = document.createElement('div');\r\n\t\tc.style.minHeight = '100px';\r\n\t\td.appendChild(c);\r\n\t\tconst cw = 0 | window.getComputedStyle(c).getPropertyValue('width');\r\n\t\twidth = d.offsetWidth - cw;\r\n\t}\r\n\tparent.removeChild(d);\r\n\treturn width;\r\n}","/**\n *\n * Neat Width\n *\n * @author Takuto Yanagida\n * @version 2021-01-25\n *\n */\n\n\nfunction initialize(tabs, opts = {}) {\n\tif (tabs.length === 0) return;\n\n\tconst lt = tabs[tabs.length - 1];\n\tconst cm = Object.assign({\n\t\tfullWidthRate   : 0.95,\n\t\tcellMinWidth    : 80,\n\t\tcellMinAspect   : 2 / 3,  // width / height\n\t\tcellMinLength   : 8,\n\t\tmaxRowSize      : 200,\n\t\tmaxBorderWidth  : 2,\n\t\tbefore          : null,  // function (table) { ...; return delay; }\n\t\tafter           : null,  // function (table) { ... }\n\t\tstyleNeat       : ':ncTableNeat',\n\t\tstyleFull       : ':ncTableFull',\n\t\tstyleScrollRight: ':ncScrollRight',\n\t\tstyleScrollLeft : ':ncScrollLeft',\n\t}, opts, getCommonMetrics(lt));\n\n\tcm.padH += cm.maxBorderWidth * 2;\n\tcm.padV += cm.maxBorderWidth * 2;\n\tcm.dcTd = makeDummyCell(lt, 'td');\n\tcm.dcTh = makeDummyCell(lt, 'th');\n\n\tconst tarTabs = [], noTarTabs = [];\n\tfor (const t of tabs) {\n\t\tif (isTarget(t, cm)) tarTabs.push(t);\n\t\telse noTarTabs.push(t);\n\t}\n\tcm.gcCount = tarTabs.length;\n\n\tfor (const t of tarTabs) {\n\t\tconst delay = (cm.before) ? (cm.before(t) ?? 0) : false;\n\t\tst(() => {\n\t\t\tapply(t, cm);\n\t\t\tenableClass(true, t, cm.styleNeat);\n\t\t\tif (cm.after) cm.after(t);\n\t\t\tif (--cm.gcCount === 0) removeDummyCell(lt, cm);\n\t\t}, delay);\n\t}\n\tif (cm.fullWidthRate) {\n\t\tfor (const t of noTarTabs) {\n\t\t\tconst pw = t.parentElement.clientWidth;\n\t\t\tif (pw * cm.fullWidthRate < t.clientWidth) enableClass(true, t, cm.styleFull);\n\t\t}\n\t}\n\tfunction st(fn, d) { (d === false) ? fn() : setTimeout(fn, d); }\n\tinitScroll(tarTabs, cm);\n}\n\nfunction getCommonMetrics(tab) {\n\tconst td = tab.getElementsByTagName('td')[0];\n\tconst s = getComputedStyle(td);\n\tconst padH  = parseFloat(s.paddingLeft) + parseFloat(s.paddingRight);\n\tconst padV  = parseFloat(s.paddingTop) + parseFloat(s.paddingBottom);\n\tconst [charW, lineH] = getTextSize(td);\n\treturn { padH, padV, charW, lineH };\n}\n\nfunction getTextSize(elm) {\n\tconst d = document.createElement(elm.nodeName);\n\td.setAttribute('style', `position:fixed;margin:0;padding:0;font-family:${elm.style.fontFamily || 'inherit'};font-size:${elm.style.fontSize || 'inherit'};`);\n\td.innerHTML = '\\u3000';  // Full width space\n\telm.parentNode.appendChild(d);\n\tconst w = d.clientWidth;\n\tconst h = d.clientHeight;\n\td.parentNode.removeChild(d);\n\treturn [w, h];\n}\n\nfunction makeDummyCell(t, tagName) {\n\tconst d = document.createElement(tagName);\n\td.setAttribute('style', `position:fixed;display:inline-block;visibility:hidden;white-space:nowrap;`);\n\treturn t.appendChild(d);\n}\n\nfunction removeDummyCell(lt, cMat) {\n\tlt.removeChild(cMat.dcTd);\n\tlt.removeChild(cMat.dcTh);\n}\n\nfunction isTarget(tab, cMet) {\n\tif (tab.rows.length === 0) return false;\n\tif (cMet.maxRowSize < tab.rows.length) return false;\n\n\tconst { cellMinWidth, cellMinAspect } = cMet;\n\tfor (const tr of tab.rows) {\n\t\tif (!tr.hasChildNodes()) continue;\n\t\tfor (const n of tr.childNodes) {\n\t\t\tconst tn = n.tagName;\n\t\t\tif (tn !== 'TD' && tn !== 'TH') continue;\n\t\t\tif (1 < parseInt(n.getAttribute('colSpan'), 10)) continue;\n\t\t\tif (1 < parseInt(n.getAttribute('rowSpan'), 10)) continue;\n\t\t\tconst cw = n.clientWidth;\n\t\t\tconst ch = n.clientHeight;\n\t\t\tif (cw < cellMinWidth || cw / ch < cellMinAspect) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction initScroll(tabs, cMet) {\n\tconst rob = new ResizeObserver(oes => {\n\t\tfor (const oe of oes) onScroll(oe.target, cMet);\n\t});\n\tfor (const t of tabs) {\n\t\trob.observe(t);\n\t\tt.addEventListener('scroll', throttle(() => { onScroll(t, cMet); }));\n\t}\n}\n\nfunction onScroll(tab, cMet) {\n\tif (tab.scrollWidth - tab.clientWidth > 2) {  // for avoiding needless scrolling\n\t\tconst r = tab.scrollLeft / (tab.scrollWidth - tab.clientWidth);\n\t\tenableClass(r < 0.95, tab, cMet.styleScrollRight);\n\t\tenableClass(0.05 < r, tab, cMet.styleScrollLeft);\n\t} else {\n\t\tenableClass(false, tab, cMet.styleScrollRight);\n\t\tenableClass(false, tab, cMet.styleScrollLeft);\n\t}\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction apply(tab, cMet) {\n\ttab.removeAttribute('width');\n\tif (tab.style.width) tab.style.width = null;\n\tif (tab.style.height) tab.style.height = null;\n\n\tconst grid  = makeCellGrid(tab);\n\tconst met   = Object.assign(getMetrics(tab, grid), cMet);\n\tconst newWs = calcNewWidths(grid, met);\n\tsetCellWidth(grid, newWs);\n\n\tconst cs = tab.getElementsByTagName('caption');\n\tif (cs.length) cs[0].innerHTML = `<span>${cs[0].innerHTML}</span>`;\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction makeCellGrid(t) {\n\tconst css = collectCells(t);\n\tlet maxWidth = 0;\n\tfor (const cs of css) maxWidth = Math.max(maxWidth, cs.length);\n\tconst g = [];\n\tfor (const cs of css) g.push(new Array(maxWidth));\n\n\tfor (let y = 0; y < g.length; y += 1) {\n\t\tconst gr = g[y];\n\t\tconst tds = css[y];\n\t\tlet i = 0;\n\n\t\tfor (let x = 0; x < maxWidth; x += 1) {\n\t\t\tif (typeof gr[x] === 'number' || gr[x] === null) continue;\n\n\t\t\tconst td = tds[i]\n\t\t\tconst col = parseInt(td.getAttribute('colSpan') ?? 1, 10);\n\t\t\tconst row = parseInt(td.getAttribute('rowSpan') ?? 1, 10);\n\t\t\tgr[x] = td;\n\n\t\t\tif (1 < col) {\n\t\t\t\tfor (let p = 1; p < col; p += 1) gr[x + p] = p;\n\t\t\t}\n\t\t\tif (1 < row) {\n\t\t\t\tfor (let q = 1; q < row; q += 1) {\n\t\t\t\t\tconst nr = g[y + q];\n\t\t\t\t\tfor (let p = 0; p < col; p += 1) nr[x + p] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti += 1;\n\t\t\tif (tds.length <= i) break;\n\t\t}\n\t}\n\treturn g;\n}\n\nfunction collectCells(t, css = []) {\n\tfor (const tr of t.rows) {\n\t\tconst cs = [];\n\t\tif (tr.hasChildNodes()) {\n\t\t\tfor (const n of tr.childNodes) {\n\t\t\t\tconst tn = n.tagName;\n\t\t\t\tif (tn === 'TD' || tn === 'TH') cs.push(n);\n\t\t\t}\n\t\t}\n\t\tcss.push(cs);\n\t}\n\treturn css;\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction getMetrics(tab, grid) {\n\tconst origTabW = tab.clientWidth;\n\tconst origCellWs = [];\n\tfor (let x = 0; x < grid[0].length; x += 1) {\n\t\tfor (let y = 0; y < grid.length; y += 1) {\n\t\t\tconst g = grid[y][x];\n\t\t\tif (g instanceof HTMLTableCellElement && !g.getAttribute('colSpan')) {\n\t\t\t\torigCellWs.push(g.clientWidth);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn { origTabW, origCellWs };\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction calcNewWidths(grid, met) {\n\tfor (const gr of grid) {\n\t\tfor (const gc of gr) {\n\t\t\tif (typeof gc !== 'number' && gc !== null) gc.style.whiteSpace = 'nowrap';\n\t\t}\n\t}\n\tconst gw = grid[0].length;\n\tconst newWs = new Array(gw).fill(0);\n\tconst fixWs = new Array(gw).fill(0);\n\n\tfor (const gr of grid) {\n\t\tfor (let x = 0; x < gw; x += 1) {\n\t\t\tconst td = gr[x];\n\t\t\tif (td === undefined || td === null || typeof td === 'number') continue;\n\t\t\tif (x < gw - 1 && typeof gr[x + 1] === 'number') continue;\n\t\t\tif (1 < parseInt(td.getAttribute('colSpan'), 10)) continue;\n\t\t\tif (1 < parseInt(td.getAttribute('rowSpan'), 10)) continue;\n\n\t\t\tconst minW = calcMinWidth(td, met);\n\t\t\tnewWs[x] = Math.max(newWs[x], minW);\n\t\t\tif (!minW) fixWs[x] = Math.max(fixWs[x], td.clientWidth);\n\t\t}\n\t}\n\twidenTabWidth(newWs, fixWs, met);\n\treturn newWs;\n}\n\nfunction calcMinWidth(td, met) {\n\tconst { padH, padV, charW, lineH, dcTd, dcTh, cellMinWidth, cellMinAspect, cellMinLength } = met;\n\tif (calcMaxLineLength(td) < cellMinLength) return 0;\n\n\ttd.innerHTML = td.innerHTML.trim();\n\tconst dc = td.tagName === 'TD' ? dcTd : dcTh;\n\tdc.innerHTML = td.innerHTML;\n\tconst aw = dc.clientWidth - padH;\n\tconst ls = Math.round((dc.clientHeight - padV) / lineH);\n\tlet minW = 0;\n\tfor (let i = 2;; i += 1) {\n\t\tconst tempW = 0 | (aw / i + charW * i + padH);\n\t\tconst tempH = ls * (i * lineH) + padV;\n\t\tif (tempW < cellMinWidth || tempW / tempH < cellMinAspect || (minW && minW < tempW)) break;\n\t\tminW = tempW;\n\t}\n\treturn (minW + charW < dc.clientWidth) ? minW : 0;\n}\n\nfunction calcMaxLineLength(td) {\n\tconst ih = td.innerHTML.trim();\n\tconst ls = ih.split(/<\\s*br\\s*\\/?>/ui);\n\tconst ts = ls.map(e => e.replace(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/g, '').length);\n\treturn Math.max(...ts);\n}\n\nfunction widenTabWidth(newWs, fixWs, met) {\n\tconst { origTabW, origCellWs } = met;\n\tlet wNew = 0, wFix = 0;\n\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\tif (newWs[i]) {\n\t\t\twNew += newWs[i];\n\t\t} else {\n\t\t\twFix += fixWs[i];\n\t\t}\n\t}\n\tif (origTabW < wNew + wFix) return;\n\tlet rem = origTabW - wFix;\n\tfor (let i = 0; i < newWs.length; i += 1) {\n\t\tif (!newWs[i]) continue;\n\t\tconst nw = newWs[i];\n\t\tconst w = Math.min(nw / wNew * rem, origCellWs[i]);\n\t\trem  -= (w - nw);\n\t\twNew -= (w - nw);\n\t\tnewWs[i] = 0 | w;\n\t}\n}\n\n\n// -------------------------------------------------------------------------\n\n\nfunction setCellWidth(grid, ws) {\n\tfor (const gr of grid) {\n\t\tfor (let x = 0; x < gr.length; x += 1) {\n\t\t\tconst gc = gr[x], w = ws[x];\n\t\t\tif (!w || !(gc instanceof HTMLTableCellElement)) continue;\n\t\t\tgc.style.whiteSpace = null;\n\t\t\tgc.style.minWidth   = w + 'px';\n\t\t\tgc.style.width      = null;\n\t\t}\n\t}\n}"]}